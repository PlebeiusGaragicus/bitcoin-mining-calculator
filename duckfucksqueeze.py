# MICAH FULLERTON 2022
# I stand on the shoulders of giants...
# https://insights.braiins.com/en/profitability-calculator/

# color picker
# https://htmlcolorcodes.com/color-picker/


TODO = """
make 'for info only' variables 
- avg subsidy
- 
"""


import os
import json
import threading

# FOR THE DELETE BUTTON ON THE LIST OF MINERS TABLE
from functools import partial
import urllib.request as ur


# FAIL GRACEFULLY AND HELP THE USER
try:
    import pywebio
    from pywebio import pin
    from pywebio import output
    from pywebio import session
except ModuleNotFoundError as oh_shit_bro:
    print("""
        you don't seem to have pywebio installed.

        This is how you fix it:

        run this: pip3 install pywebio

        if you're on MacOS you may have to run this to upgrade pip:
        #TODO
        """)
    exit(1)

try:
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
except ModuleNotFoundError as oh_shit_bro:
    print("""
        You don't have plotly installed.
        this is how you do it.

        run this: pip3 install plotly
        """)
    exit(1)




helloo= """
==========================
WELCOME to the
  open-source
   bitcoin
    mining
     profitability
      calculator!!
"""

#>> Welcome to my Open-Source Bitcoin Mining Profitability Calculator!!!
CLI_HELPTEXT = """
>> Remember: Ctrl-C to exit
"""

WEBSITES_THAT_HELPED = """
- https://mutuallyassuredpreservation.com/
- https://insights.braiins.com/en
- https://www.blockchain.com/api/blockchain_api
- https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp
- https://jsapi.apiary.io/apis/blockchaininfo/reference/simple-real-time-data/total-bitcoin/get.html
- https://pywebio.readthedocs.io/en/latest/guide.html
- https://github.com/bitcoin/bitcoin/blob/0.21/src/validation.cpp#L1236-L1247
- https://github.com/bitcoin/bitcoin/blob/0.21/src/chainparams.cpp#L69
- https://www.aniccaresearch.tech/blog/the-intelligent-bitcoin-miner-part-i
- https://www.blockchain.com/api/blockchain_api
"""

TEXT_WHAT_IS_MINING = """
Bitcoin transactions are approved through the process of mining. Mining requires work in the form of electricity and computation. Doing the work necessary for mining returns value to you in the form of satoshi's - the smallest unit of bitcoin.
"""

MAIN_TEXT = """# Open-Source Bitcoin Mining Profitability Calculator

__The goal of this project is to inspire__ people to learn more about bitcoin's built-in incentive structure - mining.

__The purpose of this tool is to__ help bitcoin miners make the best business decisions - how much to pay for equipment and what operating environment is needed to be profitable.
"""

EXPLAIN_NETWORK = """
nothing yet
"""
EXPLAIN_REWARD = """
nothing yet
"""
EXPLAIN_EXPENSE = """
nothing yet
"""
EXPLAIN_PROFITLOSS = """
"A successful miner is able to produce Bitcoin at a cost lower than the spot price, and can accordingly build a position at a steep discount compared to purchasing on the open market." [https://www.aniccaresearch.tech/blog/the-intelligent-bitcoin-miner-part-i]

It's OK if you're not making a profit! By using the heat generated by your mining equipment you can replace or suppliment other heating equipment and reduce your overall heating costs.  
"""

USER_STRATEGY_1 = 'sell only to cover expenses'
USER_STRATEGY_2 = 'HODL all'
USER_STRATEGY_3 = 'sell all'
#USER_STRATEGY_4 = 'sell to cover expense and give me X extra'

HASH     = 1 # such tiny
KILOHASH = 1_000
MEGAHASH = 1_000_000
GIGAHASH = 1_000_000_000
TERAHASH = 1_000_000_000_000
PETAHASH = 1_000_000_000_000_000
EXAHASH  = 1_000_000_000_000_000_000 # Stop ser, I'm blushing...

# number of satoshi in one bitcoin
ONE_HUNDRED_MILLION = 100_000_000

# == 144 (6 blocks per hour, for 24 hours - assuming a perfect cadence of 10 minutes per block)
EXPECTED_BLOCKS_PER_DAY = 24 * 6

# number of blocks until subsidy halves again
# https://github.com/bitcoin/bitcoin/blob/0.21/src/chainparams.cpp#L69
SUBSIDY_HALVING_INTERVAL = 210_000

### DEFAULT NUMBERS FOR THE USER INPUT FIELDS
DEFAULT_POOL_FEE = 0 # per-cent (2 == 2%; 0.1 == 0.1%) #TODO change back
DEFAUL_KPKWH = 0.075 # dollars # TODO CHANGE BACK
DEFAULT_OPEX = 15 # dollars
DEFAULT_MONTHSTOPROJECT = 36
DEFAULT_PRICEGROW = 2
DEFAULT_LAG = 12
DEFAULT_PRICEGROW2 = 15
DEFAULT_HASHGROW = 3
DEFAULT_THRESHOLD = 1000000




# THESE ARE THE NAMES OF THE 'PIN' INPUT FIELDS
# bitcoin price
PIN_PRICEGROW = 'pricegrow'
PIN_LAG = 'lag'
PIN_PRICEGROW2 = 'pricegrow2'
# miner analysis
PIN_CAPEX = 'satsPerTH'
PIN_EFF = 'eff'
# bitcoina network state
PIN_HEIGHT = 'height'
PIN_AVERAGEFEE = 'avgfee'
PIN_NETWORKHASHRATE = 'nh'
PIN_HASHGROW = 'hashgrow'
# PROJECTION PARAMETERS
PIN_KWH_RATE = 'costkwh'
PIN_POOLFEE = 'poolfee'
PIN_OPEX = 'opex'
PIN_MONTHSTOPROJECT = 'months'


# THESE ARE DICTIONARY ITEM NAMES FOR THE RESULTS DICT WE CALCULATE
KEY_ESTIMATED_HEIGHT = 'height'
KEY_ESTIMATED_NETWORK_HASHRATE = 'network_hashrate'
KEY_ESTIMATED_PRICE = 'price btc'
KEY_ESTIMATED_AVGFEE = 'avgfee'
# WHAT WE EARN / WHAT WE BURN
KEY_HASHVALUE = 'hv'
KEY_KWH = 'kwh'
# SATS THAT ARE SOLD TO KEEP THE BUSINESS GOING
KEY_SOLD_ELECTRICITY = 'sold_electricity'
KEY_SOLD_OPEX = 'sold_OPEX'
KEY_SOLD_CAPEX = 'sold_CAPEX'
# EXTRA ANALYSIS
KEY_BREAKEVEN_PRICE = 'BE price'
KEY_BREAKEVEN_PRICE_P20P = 'BE price 20%'
KEY_BREAKEVEN_NH = 'BE hashrate'
# THE (CONSTANT) PARAMETERS FOR THIS PROJECTION CALCULATION
KEY_HASH_GROWTH = 'hash growth'
KEY_PRICE_GROWTH = 'price growth'
KEY_START_HEIGHT = 'start height'
KEY_RATE_KWH = 'rate kwh'
KEY_CAPEX = 'capex'
KEY_OPEX = 'opex'


def block_subsity( height ):
    return (50 * ONE_HUNDRED_MILLION) >> (height // SUBSIDY_HALVING_INTERVAL)


###################
class userState:
    miners = []

    def total_wattage(self):
        w = 0
        for m in self.miners:
            w += m["wattage"]# * m["quantity"]
        return w
    def total_capex(self):
        c = 0
        for m in self.miners:
            c += m["cost"]# * m["quantity"]
        return c
    def total_terahash(self):
        t = 0
        for m in self.miners:
            t += (m["hashrate"])# * m["quantity"]
        return t
#####################
class networkState:
    # TODO find a way to DO THIS BETTER...
    price_bitcoin = 30_515.13
    price_satoshi = price_bitcoin / ONE_HUNDRED_MILLION
    block_height = 738_592
    block_subsidy = 6.25
    fee_average = 9_000_000
    estimated_hashrate = 227 * MEGAHASH

    #difficulty = []
    #qdiffstep = 10 # nblocks that we query difficulty
    #TODO  can you calculate the range of network hashrate that will produce a good average block time?

    #def update(self, price, height, avg_fee, diff, nethashps):
    def update(self, price, height, avg_fee, nethashps):
        """
            # #TODO - find again this reference.. intel' b' miner?
            # network_terahashrate + your_terahashrate / your_terahashrate
        """
        self.price_bitcoin = price
        self.price_satoshi : float = self.price_bitcoin / ONE_HUNDRED_MILLION
        self.block_height = height
        #https://github.com/bitcoin/bitcoin/blob/0.21/src/validation.cpp#L1236-L1247
        self.block_subsidy = block_subsity( self.block_height ) #(50 * ONE_HUNDRED_MILLION) >> (self.block_height // SUBSIDY_HALVING_INTERVAL)
        self.fee_average = avg_fee
        #self.difficulty = diff
        self.estimated_hashrate = nethashps

    def blocks_until_next_halvening(self):
        """
            - this is calculated off of current block height - easy.
            # TODO - where did I get this? insights source code?
        """
        return ((self.block_height // SUBSIDY_HALVING_INTERVAL + 1) * SUBSIDY_HALVING_INTERVAL) - self.block_height
##########################################################################################################################



# THE GLOBAL VARIABLES - instantiate the singularities! <3 <3
us = userState()
ns = networkState()

# TODO - DEBUG ONLY
#us.miners.append({"name":"S9","wattage":999,"hashrate":12,"cost":500,"quantity":1})






def blocks_until_halvening(block_height):
    return ((block_height // SUBSIDY_HALVING_INTERVAL + 1) * SUBSIDY_HALVING_INTERVAL) - block_height


def useful_node():
    """
        returns node path if node is (1) found, (2) running, (3) up-to-date - no in IDB

        returns None on error
    """

    bin_path = os.popen("which bitcoin-core.cli").read().strip('\n')
    if bin_path == '':
        bin_path = os.popen("which bitcoin-cli").read().strip('\n')
        if bin_path == '':
            print("ERROR: could not find bitcoin core")
            return None

    print("bitcoin core found at:", bin_path)

    try:
        # TODO provide link to docs
        #node_info = json.loads( os.popen(f"{bin_path} getblockchaininfo").read() )
        # stderr is thrown away... I'm going to tell the 
        node_info = json.loads( os.popen(f"{bin_path} getblockchaininfo 2> /dev/null").read() )

        ibd = bool( node_info['initialblockdownload'] )
        progress = float( node_info['verificationprogress'] )
    except:
        print("ERROR: your bitcoin node is not running.")
        return None

    print(node_info)

    if ibd == True:
        print(f"ERROR: your node is currently downloading the blockchain, it does not have a full copy yet ({float(progress * 100):.0f}% downloaded)")
        return None

    print(f">> your node appears up-to-date")

    return bin_path


def node_blockheight(bcli_path) -> int:
    """
    this will run bitcoin-cli at the supplied path
    TODO - provide link to bitcoin documentatiopn of 'getblockcount'
    """
    return int(os.popen(f"{bcli_path} getblockcount").read())


def node_blockhash(bcli_path, height) -> int:
    """
        TODO - I need a link to bitcoin documentation here
    """
    return os.popen(f"{bcli_path} getblockhash {height}").read()


def node_networkhashps(bcli_path, nblocks=120, height=-1) -> float: # use -1 for nblocks to go since last diff change
    """
    """
    # https://developer.bitcoin.org/reference/rpc/getnetworkhashps.html
    nh = os.popen(f"{bcli_path} getnetworkhashps {nblocks} {height}").read()
    return float( nh.split('\n')[0] )


def node_avgblockfee(bcli_path, nBlocks = EXPECTED_BLOCKS_PER_DAY) -> int:
    """
    """
    blockheight = int(os.popen(f"{bcli_path} getblockcount").read())

    output.put_text(f"Calculating average block fee from last {nBlocks} blocks - please wait...", scope='init')

    total_fee = 0
    for bdx in range(blockheight-nBlocks, blockheight):
        block_fee = int( os.popen(f"""{bcli_path} getblockstats {bdx} '["totalfee"]'""").read().split(': ')[1].split('\n')[0] )        
        total_fee += block_fee
        output.put_markdown(f"```block: {bdx} --> fee: {block_fee:,}```", scope='init')
        #output.scroll_to(scope="init", position="bottom")

    total_fee /= nBlocks

    return total_fee





def usd(satoshi, price=None):# , btc_price: float=ns.price_bitcoin):
    if price != None:
        return satoshi * (price / ONE_HUNDRED_MILLION)
    else:
        return satoshi * (ns.price_bitcoin / ONE_HUNDRED_MILLION)

# def btc(dollars): #, sat_price: float=ns.price_satoshi):
#     return dollars / ns.price_satoshi

def btc(dollars, price=None): #, sat_price: float=ns.price_satoshi):
    if price != None:
        return int(ONE_HUNDRED_MILLION * (dollars / price))
    else:
        return int(dollars / ns.price_satoshi)






#################################
def popup_get_price_from_user():
    """
        This creates a pop-up that asks the user for the bitcoin price
        This is used if we were unable to download the price from the internet
    """
    result = popup_input([
        pin.put_input('price', label='bitcoin price', type='float', value=ns.price_bitcoin)
        ], names=['price'], title="What is the current bitcoin price?")

    # USER HIT CANCEL
    if result == None:
        return -1

    if result['price'] == None or result['price'] <= 0:
        output.toast("invalid price")
        return -1
    else:
        p = result['price']

    return p



#####################################
def popup_get_stats_from_user() -> bool:
    """
        this pop up asks the user for network stats
    """
    result = popup_input([
        pin.put_input('in height', label='block height', type='number', value=ns.block_height),
        #pin.put_input('difficulty', label='difficulty', type='number', value=ns.difficulty),
        pin.put_input('in hashrate', label='network hashrate (in terahashes)', type='float', value=ns.estimated_hashrate),
        pin.put_input('in price', label='bitcoin price', type='float', value=ns.price_bitcoin),
        pin.put_input('in fee', label='average fee (in satoshi)', type='float', value=ns.fee_average)
        ], names=['in height', 'in hashrate', 'in price', 'in fee'], title="Enter the current bitcoin network status")

    # USER HIT CANCEL
    if result == None:
        return False

    # VERIFY USER INPUT
    if result['in height'] == None or result['in height'] < 0:
        output.toast("invalid height")
        return False
    else:
        h = result['in height']
    # if result['difficulty'] == None or result['difficulty'] <= 0:
    #     output.toast("invalid difficulty")
    #     return False
    # else:
        # d = result['difficulty']
    if result['in hashrate'] == None or result['in hashrate'] <= 0:
        output.toast("invalid hashrate")
        return False
    else:
        nh = result['in hashrate']
    if result['in price'] == None or result['in price'] <= 0:
        output.toast("invalid price")
        return False
    else:
        p = result['in price']
    if result['in fee'] == None or result['in fee'] <= 0:
        output.toast("invalid fee")
        return False
    else:
        f = result['in fee']

    #ns.update(price=p, height=h, avg_fee=f, diff=d, est_hr=hr)
    ns.update(price=p, height=h, avg_fee=f, nethashps=nh)

    #show_network()
    return True


########################################
def get_stats_from_internet() -> bool:
    """
        https://www.blockchain.com/api/q
    """
    output.put_text("Gathering data from blockchain.info...", scope='init')

    try:
        h = int(ur.urlopen(ur.Request('https://blockchain.info/q/getblockcount')).read())
        #d = int(float(ur.urlopen(ur.Request('https://blockchain.info/q/getdifficulty')).read()))
        nh = int(ur.urlopen(ur.Request('https://blockchain.info/q/hashrate')).read()) / 1000
        p = query_bitcoinprice() #int(float(ur.urlopen(ur.Request('https://blockchain.info/q/24hrprice')).read()))

        output.put_text("Getting average block fee from internet... please wait...!!!", scope='init')
        #f = get_average_block_fee_from_internet(nBlocks=1) # TODO - DEBUG ONLY
        f = 9_000_000 # TODO - DEBUG ONLY # TODO - DEBUG ONLY # TODO - DEBUG ONLY
    except:
        output.toast("Could not download network status.", color='error', duration=7)
        return False

    ns.update(price=p, height=h, avg_fee=f, nethashps=nh)
    
    return True



# https://www.blockchain.com/api/blockchain_api
# https://blockchain.info/rawblock/<block_hash> _OR_ https://blockchain.info/rawblock/<block_hash>?format=hex
def get_average_block_fee_from_internet(nBlocks = EXPECTED_BLOCKS_PER_DAY) -> int:
    """
    """
    # TODO - USE A TRY EXCEPT BLOCK... OR ELSE FUCK FUCK FUCK.. ALSO JUST RETURN 0 AND ALERT THE USER WITH OUTPUT.TOAST
    latest_hash = str(ur.urlopen(ur.Request('https://blockchain.info/q/latesthash')).read(),'utf-8')
    total_fee = 0
    for _ in range(0, nBlocks):
        block_data = str(ur.urlopen(ur.Request(f'https://blockchain.info/rawblock/{latest_hash}')).read())
        block_fee = int(block_data.split('"fee":')[1].split(',')[0])
        height = int(block_data.split('"height":')[1].split(',')[0])
        total_fee += block_fee
        #output.put_markdown(f"```block: {height} --> fee: {block_fee:,}```", scope='init')
        block_height = int(block_data.split('"block_index":')[1].split(',')[0])
        latest_hash = block_data.split('"prev_block":')[1].split(',')[0].strip('"')
        print("block: ", block_height, " -->  fee: ", format(block_fee, ',').rjust(11), " satoshi")

    total_fee /= nBlocks
    print(f"Average fee per block in last {nBlocks} blocks:", f'{total_fee:,.0f}')
    return total_fee




#API_URL = 'https://api.coindesk.com/v1/bpi/currentprice.json'
# float( data['bpi']['USD']['rate_float'] )
#price = float( data["data"]["amount"].split(".")[0].replace(',', '') )
#price = data["data"]["amount"].replace(',', '')
def query_bitcoinprice() -> float:
    """
        - queries the current bitcoin price from the coindesk.com API

        - returns (-1) on error

        - shell one-liner:
            - alias btcprice = "curl -s 'https://api.coinbase.com/v2/prices/spot?currency=USD' | jq -r '.data.amount'"
    """

    try:
        API_URL = 'https://api.coinbase.com/v2/prices/spot?currency=USD'
        response = ur.urlopen(ur.Request( API_URL )).read()
        data = json.loads(response) # returns dict
        price = float( data['data']['amount'] )
    except:
        return -1

    return price








def user_cost_kWh() -> float:
    if pin.pin['costkwh'] == None:
        return None # TODO WHY DID I DO THIS?
    return pin.pin['costkwh']

def user_pool_fee() -> float:
    if pin.pin['poolfee'] == None:
        return None # TODO WHY DID I DO THIS?
    return pin.pin['poolfee'] / 100

def user_opex() -> int:
    if pin.pin['opex'] == None:
        return None # TODO WHY DID I DO THIS?
    return pin.pin['opex']










##############################
def currencyconverter():
    def updateprice():
        pin.pin['price'] = query_bitcoinprice()

    def convert_to_sat():
        amnt = float(pin.pin["amount"])
        price = float(pin.pin["price"])
        r = float(ONE_HUNDRED_MILLION * (amnt / price))
        pin.pin["result"] = f"${amnt:,.2f} @ ${price:,.2f} = {r:.2f} sats / {r / ONE_HUNDRED_MILLION:.2f} bitcoin\n" + pin.pin['result']

    def convert_to_usd():
        amnt = float(pin.pin["amount"])
        price = float(pin.pin["price"])
        r = amnt * (price / ONE_HUNDRED_MILLION)
        pin.pin["result"] = f"{amnt:,.2f} sats @ ${price:,.2f} = ${r:,.2f}\n" + pin.pin['result']

    output.popup('USD - BTC converter', content=[
        output.put_row(content=[
            output.put_column(content=[
                pin.put_input("price", type="float", label="Price of bitcoin:", value=query_bitcoinprice()),
                output.put_button("refresh price", onclick=updateprice)
                ]),
            output.put_column(content=[
                pin.put_input("amount", type="float", label="Amount to convert"),
                output.put_column(content=[
                    output.put_button("sats -> dollars", onclick=convert_to_usd),
                    output.put_button("dollars -> sats", onclick=convert_to_sat)
                    ])
                ])
        ]),
        pin.put_textarea("result", label="Result:", value="", readonly=True)
    ], closable=True)


def showstepbystep():
    # use 1TH and show calculation for hash value.. ETC ETC ETC
    output.toast("not implemented yet... sorry")

def hashratehistory():
    # https://www.tradingview.com/
    output.toast("not implemented yet... sorry")

def pricehistory():
    # make a fucking moving average
    output.toast("not implemented yet... sorry")

###################################### THIS FUNCTION ROCKS!!!!!!!!! SAVE THIS!!!!!!!
#def popup_input(pins, names, title):
# onchangepinname='examples', onchange=changeentries)
def popup_input(pins, names, title, onchangepinname=None, callback=None):
    """
        Show a form in popup window.
        :param list pins: pin output list.
        :param list pins: pin name list.
        :param str title: model title.
        :return: return the form as dict, return None when user cancel the form.
    """
    if not isinstance(pins, list):
        pins = [pins]

    event = threading.Event()
    confirmed_form = None

    def onclick(val):
        nonlocal confirmed_form
        confirmed_form = val
        event.set()

    pins.append(output.put_buttons([
        {'label': 'Submit', 'value': True},
        {'label': 'Cancel', 'value': False, 'color': 'danger'},
    ], onclick=onclick))
    output.popup(title=title, content=pins, closable=False)
    
    if not onchangepinname == None:
        pin.pin_on_change(onchangepinname, onchange=callback)

    event.wait()
    output.close_popup()
    if not confirmed_form:
        return None

    return {name: pin.pin[name] for name in names}



##########################
def add_miner_dialog():
    """
        THIS MAKES THE POPUP APPEAR AND BLOCKS (waits for user input before continuuing execution)
    """
    result = popup_input([
        #pin.put_input('name', label='name', value='S19'),
        pin.put_input('wattage', label='wattage', type="number", value=3010),
        pin.put_input('hashrate', label='hashrate (in terahashes)', type="float", value=90),
        pin.put_input('cost', label='cost', type="float", value=18220338.98),
        pin.put_radio("units", label='cost unit', options=["bitcoin", "fiat"], value='bitcoin'),
        pin.put_input('quantity', label='quantity', type="number", value=1)
    #], names=['name', 'wattage', 'hashrate', 'cost', 'units', 'quantity'], title="Enter the details of your miner")
    ], names=['wattage', 'hashrate', 'cost', 'units'], title="Enter the details of your miner")

    # USER HIT CANCEL
    if result == None:
        return

    # VERIFY USER INPUT
    # if result['name'] == None or len(result['name']) > 50:
    #     output.toast("invalid name - no miners added")
    #     return
    if result['wattage'] == None or result['wattage'] <= 0:
        output.toast("invalid wattage - no miners added")
        return
    if result['hashrate'] == None or result['hashrate'] <= 0:
        output.toast("invalid hashrate - no miners added")
        return
    if result['cost'] == None or result['cost'] <= 0:
        output.toast("invalid cost - no miners added")
        return
    if result['units'] == 'fiat':
        output.toast("Note: the cost of the miner will be converted from fiat (dollars) to satoshi using current price data", color='warn', duration=7)
        #result['cost'] = btc( result['cost'], sat_price=ns.price_satoshi )
        result['cost'] = btc( result['cost'] )

    if result['quantity'] == None or result['quantity'] <= 0:
        output.toast("invalid quantity - no miners added")
        return

    del result['units']

    # ADD THE MINER
    us.miners.append( result )

    # NOTIFY USER OF SUCCESS
    #t = "ADDED:  " + str(result['name']) + "  wattage: " + str(result['wattage']) + "  hashrate: " + str(result['hashrate']) + "   quantity: " + str(result['quantity'])
    #output.toast(t, duration=7, color='success')
    output.toast('miner added', color='success', duration=1)

    show_miners_list()

    # TODO - this will cause a bug... don't set to DEFAULT_P below... have another way!  Unless we make sure this function is only called once... and the value isn't reset???  Hmmm...
    capexsatsperthpermonth = us.total_capex() / pin.pin[PIN_MONTHSTOPROJECT] / us.total_terahash()

    #show_settings() # we only call this function once.....
    show_projection() # AUTO-RUN THE CALCULATION WHEN SOMEONE ADDS A MINER!  <3 SAVES A MOUSE CLICK


def changeentries(option):
    """
        This is the callback for the "examples" drop-down pin
        When the user clicks an example miner stat, this changes the input boxes in the pop up
        Just makes things easier to use, ya bish?
    """
    if option == 'S19 (3050 watts / 90 TH)':
        pin.pin['wattage'] = 3050
        pin.pin['hashrate'] = 90
    if option == 'S9 (1300 watts / 13.5 TH)':
        pin.pin['wattage'] = 1300
        pin.pin['hashrate'] = 13.5
    if option == '-':
        pin.pin['wattage'] = 0
        pin.pin['hashrate'] = 0


##########################
def add_miner_to_analyze_dialog():

    result = popup_input([
        output.put_text("Select from a list of popular bitcoin miners:"),
        pin.put_select('examples', options=['-', 'S19 (3050 watts / 90 TH)', 'S9 (1300 watts / 13.5 TH)'], multiple=False),
        output.put_text("Or, add details yourself"),
        output.put_row(content=[
            pin.put_input('wattage', label='wattage', type="number"),#, value=3010),
            pin.put_input('hashrate', label='hashrate (in terahashes)', type="float"),#, value=90),
        ]),
        # 18220338.98
        pin.put_input('btcprice', label='Bitcoin price at time of purchase', type="float", value=ns.price_bitcoin),
        pin.put_input('cost', label='Dollar cost', type="float"),#, value=5375.00), #TODO THIS IS DEBUG ONLY!!!
        #pin.put_radio("units", label='cost unit', options=["bitcoin", "fiat"], value='bitcoin'),
    ], names=['examples', 'wattage', 'hashrate', 'btcprice', 'cost'], title="Enter the details of your potential miner purchase", onchangepinname='examples', callback=changeentries)
    # pin.pin_on_change('examples', onchange=changeentries),

    # USER HIT CANCEL
    if result == None:
        return

    # VERIFY USER INPUT
    if result['wattage'] == None or result['wattage'] <= 0:
        output.toast("invalid wattage - no miners added")
        return
    if result['hashrate'] == None or result['hashrate'] <= 0:
        output.toast("invalid hashrate - no miners added")
        return
    if result['cost'] == None or result['cost'] <= 0:
        output.toast("invalid cost - no miners added")
        return

    # we convert the dollar cost to satoshis using the provided bitcoin price at time of equipment purchase
    result['cost'] = btc( result['cost'], price=result['btcprice'])

    del result['examples']
    del result['btcprice']

    # ADD THE MINER
    us.miners.append( result )

    # NOW WE HAVE TO CHANGE THE PIN INPUTS PIN_CAPEX AND PIN_EFF
    # oh... and ALSO the sliders right below them
    pin.pin[PIN_CAPEX] = pin.pin['play_with_capex'] = result['cost'] / result['hashrate']
    pin.pin[PIN_EFF] = pin.pin['play_with_eff'] = round(result['wattage'] / result['hashrate'], 1)

    # NOTIFY USER OF SUCCESS
    output.toast('Analyzing miner profitability...', color='success', duration=2)

    show_miners_list()

    # TODO - this will cause a bug... don't set to DEFAULT_P below... have another way!  Unless we make sure this function is only called once... and the value isn't reset???  Hmmm...
    capexsatsperthpermonth = us.total_capex() / pin.pin[PIN_MONTHSTOPROJECT] / us.total_terahash()

    #show_settings() # we only call this function once.....
    show_projection() # AUTO-RUN THE CALCULATION WHEN SOMEONE ADDS A MINER!  <3 SAVES A MOUSE CLICK



############################
def delete_miner( row ):
    del us.miners[ row ]
    output.toast("miner removed", duration=3, color='warn')

    show_miners_list()
    #show_settings()
    show_projection()

def popup_analyze_miner():
    def convert_to_usd():
        amnt = float(pin.pin["amount"])
        price = float(pin.pin["price"])
        r = amnt * (price / ONE_HUNDRED_MILLION)
        pin.pin["result"] = f"{amnt:,.2f} sats @ ${price:,.2f} = ${r:,.2f}\n" + pin.pin['result']

    output.popup('USD - BTC converter', content=[
        output.put_row(content=[
            output.put_column(content=[
                pin.put_input("price", type="float", label="Price of bitcoin:", value=query_bitcoinprice()),
                output.put_button("refresh price", onclick=convert_to_usd)
                ]),
            output.put_column(content=[
                pin.put_input("amount", type="float", label="Amount to convert"),
                ])
        ]),
        pin.put_textarea("result", label="Result:", value="", readonly=True)
    ], closable=True)



####################
def show_miners_list():

    # TODO I don't like this...
    if ns.block_height == 0:
        return

    with output.use_scope( 'mine', clear=True):
        output.put_markdown('# Mining equipment purchase consideration')

        if len(us.miners) > 0:
            # SHOW TABLE OF MINERS
            for idx, m in enumerate(us.miners):
                output.put_table([[
                    #output.put_text( f"{idx+1}"),
                    #output.put_markdown( f"name:\n```{str(m['name'])}```" ),
                    output.put_markdown( f"wattage:\n```{str(m['wattage'])}```" ),
                    output.put_markdown( f"hashrate:\n```{str(m['hashrate'])}```"),
                    output.put_markdown( f"cost:\nsats: ```{float(m['cost']):,.2f}```\nbtc: ```{float(m['cost']) / ONE_HUNDRED_MILLION:.2f}```\n```${usd(float(m['cost'])):,.2f}```"),
                    #output.put_markdown( f"quantity:\n```{str(m['quantity'])}```" ),
                    #output.put_button(['analyze'], onclick=partial(popup_analyze_miner, row=idx), color='success'),
                    output.put_button(['remove'], onclick=partial(delete_miner, row=idx), color='danger')
                    ]])
        else:
            output.put_markdown("use the __ANALYZE MINER__ button below")
            # can be one of: `primary`, `secondary`, `success`, `danger`, `warning`, `info`, `light`, `dark`.
            #output.put_button( 'ADD MINER', onclick=add_miner_dialog, color='warning' )
            output.put_button( 'ANALYZE MINER', onclick=add_miner_to_analyze_dialog, color='success' )

##########################
def pretty_graph(res):
    """
        this takes the projection results and returns a pretty graph
    """
    #fig = go.Figure()
    fig = make_subplots(specs=[[{"secondary_y": True}]])

    fig.add_trace(
        go.Scatter(
            x=[*range( len(res[KEY_HASHVALUE]) ), res[KEY_ESTIMATED_HEIGHT]],
            #y=res[KEY_SATS_SOLD],
            # make these negative numbers... ;)
            #y=[round(e, 1) for e in res[KEY_SATS_SOLD]],
            y=res[KEY_HASHVALUE],
            name="hashvalue * TH",
            line_color="#A50CAC" # PURPLE
        ), secondary_y=False)
    fig.add_trace(
        go.Bar(
            x=[*range( len(res[KEY_SOLD_CAPEX]) )],
            #y=res[KEY_SATS_SOLD],
            # make these negative numbers... ;)
            #y=[round(e, 1) for e in res[KEY_SATS_SOLD]],
            #y=res[KEY_SOLD_OPEX],
            y=[round(e, 1) for e in res[KEY_SOLD_CAPEX]],
            name="sats sold for CAPEX",
            #color="#07A154" # GREEN
            #choropleth='#07A154'
            #https://plotly.com/python/bar-charts/#colored-bars
            #pattern_shape="nation", pattern_shape_sequence=[".", "x", "+"])
        ), secondary_y=False)
    fig.add_trace(
        go.Bar(
            x=[*range( len(res[KEY_SOLD_OPEX]) )],
            #y=res[KEY_SATS_SOLD],
            # make these negative numbers... ;)
            #y=[round(e, 1) for e in res[KEY_SATS_SOLD]],
            #y=res[KEY_SOLD_OPEX],
            y=[round(e, 1) for e in res[KEY_SOLD_OPEX]],
            name=f"sats sold for OPEX - ${DEFAULT_OPEX}",
        ), secondary_y=False)

    fig.add_trace(
        go.Bar(
            x=[*range( len(res[KEY_SOLD_ELECTRICITY]) )],
            #y=res[KEY_SATS_SOLD],
            # make these negative numbers... ;)
            #y=[round(e, 1) for e in res[KEY_SATS_SOLD]],
            #y=res[KEY_SOLD_ELECTRICITY],
            y=[round(e, 1) for e in res[KEY_SOLD_ELECTRICITY]],
            name="sats sold for ELECTRICITY"
        ), secondary_y=False)

    # CALCULATED BREAK-EVEN PRICE
    fig.add_trace(
        go.Scatter(
            x=[*range( len(res[KEY_BREAKEVEN_PRICE]) )],
            y=res[KEY_BREAKEVEN_PRICE],
            name="Break-even Bitcoin price",
            line_color="#CBDE12" # YELLOW
        ), secondary_y=True,)
    # THE PRICE WE ESTIMATE/FORECAST
    fig.add_trace(
        go.Scatter(
            x=[*range( len(res[KEY_ESTIMATED_PRICE]) )],
            y=[round(e, 1) for e in res[KEY_ESTIMATED_PRICE]],
            name="Predicted Bitcoin price",
            line_color="#12DE4D" # LIGHT GREEN
        ), secondary_y=True)

    # hodld = []
    # for i in range(len(res[KEY_SATS_EARNED])):
    #     hodld.append( round(res[KEY_SATS_EARNED][i] - res[KEY_SATS_SOLD][i], 1))

    # fig.add_trace(
    #     go.Bar(
    #         x=[*range( len(res[KEY_SATS_EARNED]) )],
    #         y=hodld,
    #         name="sats held"
    #     ))
    # # fig.add_trace(
    #     go.Scatter(
    #         x=[*range( len(res[KEY_ESTIMATED_NETWORK_HASHRATE]) )],
    #         # this magic just takes each element and divides..
    #         # so the units are now exahash and the numbers on the graph are such the more prettier...mmm ok?
    #         y=[e / MEGAHASH for e in res[KEY_ESTIMATED_NETWORK_HASHRATE]],
    #         name="network hashrate"
    #     ))

    # Set x-axis title
    fig.update_xaxes(title_text="xaxis title")

    # Set y-axes titles
    fig.update_yaxes(title_text="<b>satoshi</b>", secondary_y=False)
    fig.update_yaxes(title_text="<b>Bitcoin price</b>", secondary_y=True)

    fig.update_layout(barmode='stack')
    return fig.to_html(include_plotlyjs="require", full_html=False)

# THESE FUNCTIONS ARE CALLED BY THE SLIDER PIN CALLBACK AND ADJUST THE PIN INPUT THEY CORRESPOND
def adjust_pricegrow( v: float ):
    pin.pin[PIN_PRICEGROW] = round(v, 2)
    show_projection()

def adjust_pricegrow2( v: float ):
    pin.pin[PIN_PRICEGROW2] = round(v, 2)
    show_projection()

def adjust_hashgrow( v: float ):
    pin.pin[PIN_HASHGROW] = round(v, 2)
    show_projection()

def adjust_eff( v: float ):
    pin.pin[PIN_EFF] = round(v, 2)
    show_projection()

def adjust_capex(v :float):
    pin.pin[PIN_CAPEX] = round(v, 2)
    show_projection()

##########################
def show_graph(res):
    with output.use_scope("graph", clear=True):
        output.put_html( pretty_graph(res) )

##########################
def show_table(res):
    #verbose = bool(pin.pin['verbose'])
    #print("verbose:", verbose)


    # https://docs.python.org/3/library/string.html
# 1       2              3                             4
    str_table = """
| month | block height | network hashrate (exahash) | btc price |
| :--- | ---: | ---: | ---: |
"""
# 1       2      3      4   

                            #    1    2    3    4 
    str_table_row_format = """| %s | %s | %s | %s |"""

    for mdx in range(len(res[KEY_ESTIMATED_HEIGHT])):
        str_table += str_table_row_format % ( \
            f"{mdx + 1}",
            f"{res[KEY_ESTIMATED_HEIGHT][mdx]:,}",
            f"{res[KEY_ESTIMATED_NETWORK_HASHRATE][mdx]/MEGAHASH:,.2f}",
            f"{res[KEY_ESTIMATED_PRICE][mdx]:,.2f}",
        )
        str_table += '\n'
    
    # TODO - THE STORY
    # story = "Your strategy is to " + pin.pin['strategy'] + ".  "
    # story += "This means, once you have earned " + str(selling_threshold) + " sats, your can withdrawal them from your mining pool and sell or hold on to them.  "

    # total = str(int(_cost_electricity[0] + _cost_operating[0]))

    # if pin.pin['strategy'] == USER_STRATEGY_1:
    #     story += "You've decided to sell only enough sats to cover the $" +  total + " monthly expenses you have."

    # if pin.pin['strategy'] == USER_STRATEGY_2:
    #     story += "You've decided to not sell your bitcoin.  You are going to HODL.  So when it comes to the monthly expense... how will you pay your monthly bills of $" + total + "?..."  

    # if pin.pin['strategy'] == USER_STRATEGY_3:
    #     story += "You've decided to sell ALL the bitcoin you withdrawal and roll in stead money coming your way."

    with output.use_scope("table", clear=True):
        #output.put_text( story )
        #output.put_markdown("""# Monthly Breakdown""")
        
        output.put_collapse("Monthly Breakdown Table", content=[
            output.put_markdown( str_table ),
            output.put_table(tdata=[[
                    output.put_file('projection.csv', content=b'123,456,789'),
                    output.put_text("<<-- Download results as CSV file")
                ]])
        ])


##########################
def calculate_projection(months, hashgrow, pricegrow, cost_kWh, opex, capex): # TODO - FUTURE GENERALIZATION IMPROVEMENT@@@!!! , miner_list, network_stats):
    output.toast("re-calculating...", color='warn', duration=1)
    res = {
         #HEIGHT AT THE END OF THE MONTH!
        KEY_ESTIMATED_HEIGHT : [],
        KEY_ESTIMATED_NETWORK_HASHRATE : [],
        KEY_ESTIMATED_PRICE : [],
        KEY_ESTIMATED_AVGFEE : [],

        KEY_HASHVALUE : [],
        KEY_KWH : [],

        # BASICALLYYY.. THE RESULT
        # EXPENSE
        KEY_SOLD_ELECTRICITY : [],
        KEY_SOLD_OPEX : [],
        KEY_SOLD_CAPEX : [],

        # DECISION /FOREWARD-LOOKING // PROFIC ASSUMPTION MAKING-DECISION POINTS
        KEY_BREAKEVEN_PRICE : [],
        KEY_BREAKEVEN_PRICE_P20P : [],
        KEY_BREAKEVEN_NH : [],

        # THIS-RUN'S METRICS
        KEY_HASH_GROWTH : hashgrow,
        KEY_PRICE_GROWTH : pricegrow,
        # TODO _ USE THIS FOR BACKWARDS MODEL TESTING
        KEY_START_HEIGHT : ns.block_height,

        # the user's decisions
        KEY_CAPEX : [], # sats
        KEY_OPEX : [],
        KEY_RATE_KWH : [],


    }

    _blk = ns.block_height
    _price = ns.price_bitcoin
    _nh = ns.estimated_hashrate

    dollar_capex = usd(capex, price=_price)

    for _ in range(months):
        hashvalue = 0
        poolfee = 0
        _kwh = 0

        # DO ONE DAY OF CALCULATIONS
        for _ in range(30):

            if blocks_until_halvening( _blk ) < EXPECTED_BLOCKS_PER_DAY:
                print("we will cross a halvening")

                # GO BLOCK BY BLOCK
                for _ in range( EXPECTED_BLOCKS_PER_DAY ):

                    #hashvalue += us.total_terahash() * (block_subsity( _blk ) + ns.fee_average) * (1 - user_pool_fee()) / _nh
                    hashvalue += (block_subsity( _blk ) + ns.fee_average) * (1 - user_pool_fee()) / _nh
                    poolfee += (block_subsity( _blk ) + ns.fee_average) * user_pool_fee() / _nh
                    #_kwh += us.total_wattage() / 6000
                    _kwh += us.total_wattage() / 6000 / us.total_terahash()

                    _blk += 1

            # DO A WHOLE DAY AT A TIME
            else:
                print("we will NOT cross a halvening - calculating one day : at block ", _blk, " until:", blocks_until_halvening(_blk ))

                #hashvalue += us.total_terahash() * (block_subsity( _blk ) + ns.fee_average) * (1 - user_pool_fee()) * EXPECTED_BLOCKS_PER_DAY / _nh
                hashvalue += (block_subsity( _blk ) + ns.fee_average) * (1 - user_pool_fee()) * EXPECTED_BLOCKS_PER_DAY / _nh
                #_kwh += 24 * us.total_wattage() / 1000 / us.total_terahash()
                _kwh += 24 * us.total_wattage() / 1000 / us.total_terahash()

                _blk += EXPECTED_BLOCKS_PER_DAY

            # END OF DAY STUFF
            _nh *= 1 + hashgrow / 30

        # END OF MONTH STUFF - now we have to settle
        _price *= 1 + pricegrow # 1 + pricegrow / 30 # daily

        # TODO
        # if no profit
            # unplug
        sold_e = btc(_kwh * cost_kWh, price=_price)
        sold_o = btc(opex / us.total_terahash(), price=_price)
        sold_c = us.total_capex() / months / us.total_terahash() #already in btc terms

        # if sold_e + sold_o + sold_c > hashvalue:
        #     hashvalue = 0
        #     sold_e = 0
        #     sold_o = 0
        #     sold_c = 0

        res[KEY_ESTIMATED_HEIGHT].append( _blk )
        res[KEY_ESTIMATED_NETWORK_HASHRATE].append( _nh )
        res[KEY_ESTIMATED_PRICE].append( _price )
        res[KEY_ESTIMATED_AVGFEE].append( 0 )

        res[KEY_HASHVALUE].append( hashvalue )
        res[KEY_KWH].append( _kwh )

        res[KEY_SOLD_ELECTRICITY].append( sold_e )
        res[KEY_SOLD_OPEX].append( sold_o )
        res[KEY_SOLD_CAPEX].append( sold_c )

        # basically, just the decision/assumption-making/verifying helper variables
        #beprice = hashvalue * ((_kwh * cost_kWh) + (dollar_capex) + (opex / us.total_terahash())) / ONE_HUNDRED_MILLION WRONG WRONG WRONG
        beprice = ONE_HUNDRED_MILLION * ((_kwh * cost_kWh) + (dollar_capex) + (opex / us.total_terahash())) / hashvalue
        res[KEY_BREAKEVEN_PRICE].append( beprice )
        # KEY_BREAKEVEN_PRICE_P20P : [],
        # KEY_BREAKEVEN_NH : [],


    output.toast("done.", color='success', duration=1)
    return res








###############################
def show_projection():
    if len(us.miners) < 1:
        output.toast("You have no miners", color='error')
        output.clear('graph')
        output.clear('projection')
        output.clear('table')
        return

    # TODO - really fix this fucking BLAH!@
    if user_cost_kWh() == None or user_pool_fee() == None or user_opex() == None:
        output.toast("can't leave input field blank", color='error')
        return


    # TODO fix this... make it a function that is easier and neater and less prone to mistakes.
    months = pin.pin['months']
    hashgrow = pin.pin['hashgrow'] / 100
    pricegrow = pin.pin['pricegrow'] / 100

    #TODO SANITIZE INPUT - do a better job
    if None in [months, pricegrow, hashgrow]:
        output.toast("missing projection parameters...")
        return

    #output.scroll_to('settings', position=output.Position.BOTTOM)

    # PRINT EVERYTHING TO THE SCREEN...
    with output.use_scope('projection', clear=True):
        output.put_markdown( "# PROJECTION SUMMARY:" )

    ## ACTUALLY DO THE CALCULATIONS
    res = calculate_projection(months, hashgrow, pricegrow, cost_kWh=user_cost_kWh(), opex=user_opex(), capex=us.total_capex())

    show_graph(res)
    show_table(res)

    output.scroll_to('projection', position=output.Position.TOP)








#######################
def show_settings():
    with output.use_scope("settings", clear=True):

        output.put_markdown("## Mining equipment analysis")

        # MINER CAPEX - SATS/TH
        output.put_row(content=[
            pin.put_input(name=PIN_CAPEX, type='float', value=0),
            output.put_text("CAPEX (measured in satoshi per terahash)")
        ])
        pin.put_slider("play_with_capex", value=0,min_value=0.0, max_value=1_000_000.0, step=1 ),
        pin.pin_on_change('play_with_capex', onchange=adjust_capex)
        # MINER EFF
        output.put_row(content=[
            pin.put_input(name=PIN_EFF, type='float', value=0),
            output.put_text("miner efficiency (measured in watts burned per terahash generated - W/TH)")
        ])
        pin.put_slider("play_with_eff", value=0,min_value=1.0, max_value=170.0, step=1 ),
        pin.pin_on_change('play_with_eff', onchange=adjust_eff)
        
        output.put_markdown("---")
        output.put_markdown("## Bitcoin price")
        output.put_row(content=[
            pin.put_input(name='price', type='float', value=ns.price_bitcoin),
            output.put_text("bitcoin spot price")
        ])
        output.put_row(content=[
            pin.put_input(PIN_PRICEGROW, type='float', value=DEFAULT_PRICEGROW),
            output.put_text('Monthly price growth: %')
            #pin.put_slider("price_growth_slider", value=DEFAULT_PRICEGROW,min_value=-10.0, max_value=20.0, step=0.1 ),
        ])
        pin.put_slider("price_growth_slider", label='Price growth slider', value=DEFAULT_PRICEGROW2,min_value=-10.0, max_value=20.0, step=0.1 )
        pin.pin_on_change('price_growth_slider', onchange=adjust_pricegrow)

        output.put_collapse("post-halvening growth:", content=[
            output.put_row(content=[
                pin.put_input(name=PIN_LAG, type='float', value=DEFAULT_LAG),
                output.put_text('Halvening price lag (months)')
            ]),
            output.put_row(content=[
                pin.put_input(PIN_PRICEGROW2, type='float', value=DEFAULT_PRICEGROW),
                output.put_text('Post-halvening price growth: %')
            ]),
            pin.put_slider(name="post_growth_slider", label='Price growth slider', value=DEFAULT_PRICEGROW,min_value=-10.0, max_value=20.0, step=0.1 )
        ])
        pin.pin_on_change(name='post_growth_slider', onchange=adjust_pricegrow2)

        output.put_markdown("---")
        output.put_markdown("## Bitcoin network state")
        output.put_row(content=[
            pin.put_input(name=PIN_HEIGHT, type='float', value=ns.block_height),
            output.put_text("blockchain height")
        ])
        output.put_row(content=[
            pin.put_input(name=PIN_AVERAGEFEE, type='float', value=ns.fee_average),
            output.put_text("average transactions fees per block")
        ])
        output.put_row(content=[
            pin.put_input(name=PIN_NETWORKHASHRATE, type='float', value=ns.estimated_hashrate),
            output.put_text("network hashrate")
        ])
        output.put_row(content=[
            pin.put_input(name=PIN_HASHGROW, type='float', value=DEFAULT_HASHGROW),
            #pin.put_slider("play_with_growth", value=DEFAULT_HASHGROW,min_value=-2.0, max_value=10.0, step=0.1 ),
            output.put_text('Monthly hashrate growth: %')
        ])
        pin.put_slider("play_with_growth", value=DEFAULT_HASHGROW,min_value=-2.0, max_value=10.0, step=0.1 ),
        pin.pin_on_change('play_with_growth', onchange=adjust_hashgrow)

        output.put_markdown("---")
        output.put_markdown("## Projection Parameters")
        output.put_row(content=[
            pin.put_input(PIN_KWH_RATE, type='float', value= DEFAUL_KPKWH),
            output.put_text('your cost per kilowatt-hour: $')
        ])
        output.put_row(content=[
            pin.put_input(PIN_POOLFEE, type='float', value= DEFAULT_POOL_FEE),
            output.put_text('mining pool fee: %')
        ])
        output.put_row(content=[
            pin.put_input(PIN_OPEX, type='float', value= DEFAULT_OPEX),
            output.put_text('monthly operational cost: $')
        ])
        output.put_row(content=[
            pin.put_input(PIN_MONTHSTOPROJECT, type='float', value=DEFAULT_MONTHSTOPROJECT),
            output.put_text('Months to project')
        ])
        
        #pin.put_checkbox('verbose', options=['VERBOSE MODE - (put every variable on the spreadsheet)'], inline=True)

        output.put_button( 're-calculate', onclick=show_projection )




#############
def main():
    session.set_env(title="bitcoin mining profitability calculator")
    print( CLI_HELPTEXT )

    # https://pywebio.readthedocs.io/en/latest/platform.html
    # https://pywebio.readthedocs.io/en/v1.2.2/guide.html#server-mode-and-script-mode
    # https://github.com/pywebio/PyWebIO/blob/dev/demos/bokeh_app.py
    # I can't believe this fucking works!!!!  Will it ever cause problems? #shrug
    t = threading.Thread(target=session.hold)
    session.register_thread(t)
    t.start()

    with output.use_scope('main', clear=True):
        output.put_markdown( MAIN_TEXT )
        #output.put_markdown("---")
        output.put_collapse(title='Analysis tools:', content=[
            output.put_row(content=[
                output.put_button("btc price history", onclick=pricehistory),
                output.put_text("something")
            ]),
                output.put_row(content=[
                    output.put_button("hashrate history tool", onclick=hashratehistory),
                    output.put_text("something")
                ]),
                output.put_row(content=[
                    output.put_button("block time analysis", onclick=currencyconverter),
                    output.put_text("something")
                ]),
                output.put_row(content=[
                    output.put_button("fee analysis", onclick=currencyconverter),
                    output.put_text("something")
                ]),
                output.put_row(content=[
                    output.put_button("step-by-step", onclick=showstepbystep),
                    output.put_text("something")
                ]),
                output.put_row(content=[
                    output.put_button("USD - BTC converter", onclick=currencyconverter),
                    output.put_text("something")
                ])
        ])

        #output.put_collapse("websites that I found to be helpful:", content=[output.put_markdown(WEBSITES_THAT_HELPED)])])
        # output.put_collapse("TOOLS:", content=[
        #     output.put_row(content=[
        #         output.put_button("USD - BTC converter", onclick=currencyconverter),
        #         output.put_button("show step-by-step", onclick=showstepbystep),
        #         output.put_button("hashrate history", onclick=hashratehistory),
        #         output.put_button("btc price history", onclick=pricehistory)
        #     ])
        #     ], open=True)
    
    with output.use_scope('init', clear=True):

        path = useful_node()

        if path != None:
            output.put_text("Getting data from node...", scope='init')

            h = node_blockheight(path)
            f = node_avgblockfee(path, nBlocks=2)
            nh = node_networkhashps(path)
            
            output.put_text("Getting price of bitcoin...", scope='init')
            p = query_bitcoinprice()

            if p == -1:
                output.toast("Unable to download current bitcoin price from <some website>")
                p = popup_get_price_from_user()

            ns.update(price=p, height=h, avg_fee=f, nethashps=nh)

        else:
            if not get_stats_from_internet():
                if not popup_get_stats_from_user():
                    output.toast("FUCK... quitting")
                    exit(1)

        #us.miners.append({"name":"S19","wattage":3050,"hashrate":90,"cost":18220338,"quantity":1})
        # 18220338.98 sats

        output.clear(scope='init')
        #show_network()
        show_miners_list()
        show_settings()

#############################
if __name__ == '__main__':
    pywebio.start_server(main, port=8080, debug=True)








        # output.put_row(content=[
        #     output.put_column(content=[
        #         output.put_row(content=[
        #             output.put_text('$ / kilowatt-hour:  $'),
        #             pin.put_input('costkwh', type='float', value= DEFAUL_KPKWH)
        #         ]),

        #         output.put_row(content=[
        #             output.put_text('mining pool fee:  %'),
        #             pin.put_input('poolfee', type='float', value= DEFAULT_POOL_FEE),
        #         ]),

        #         output.put_row(content=[
        #             output.put_text('monthly OPEX: $'),
        #             pin.put_input('opex', type='float', value= DEFAULT_OPEX)
        #         ]),

        #         output.put_row(content=[
        #             output.put_text('Months to project'),
        #             pin.put_input('months', type='float', value=DEFAULT_PROJECTIONTIMELINE)
        #         ])
        #     ]),
        #     output.put_column(content=[
        #         output.put_text('Monthly hashrate growth: %'),
        #         pin.put_input('hashgrow', type='float', value=DEFAULT_HASHGROW), #readonly=True
        #         pin.put_slider("play_with_growth", value=DEFAULT_HASHGROW,min_value=-2.0, max_value=10.0, step=0.1 ),

        #         output.put_markdown("---"),

        #         output.put_text('Monthly price growth: %'),
        #         pin.put_input('pricegrow', type='float', value=DEFAULT_PRICEGROW),
        #         pin.put_slider("price_growth_slider", value=DEFAULT_PRICEGROW,min_value=-10.0, max_value=20.0, step=0.1 )
        #     ])
        # ])


        #total = ns.block_subsidy + ns.fee_average
        #output.put_markdown('# BITCOIN NETWORK STATUS')
        #output.put_markdown(f"- One Bitcoin is priced at __${ns.price_bitcoin:,}__ and one satoshi is worth __${ns.price_satoshi:.5f}__")
        #output.put_markdown(f"- There have been __{ns.block_height:,}__ blocks mined and the next halvening is in __{ns.blocks_until_next_halvening():,}__ blocks (__{ns.blocks_until_next_halvening()/144:.1f}__ days)")
        #output.put_markdown(f"- The current block reward is __{(ns.block_subsidy / ONE_HUNDRED_MILLION)}__ bitcoin (__{ns.block_subsidy:,}__ satoshi)")
        #output.put_markdown(f"- Transactions fees average __{ns.fee_average/ONE_HUNDRED_MILLION:,.3f}__ bitcoin (__{ns.fee_average:,.0f}__ satoshi) per block in the last 24 hours")
        #output.put_markdown(f"- This makes the average total reward __{total/ONE_HUNDRED_MILLION:.2f}__ bitcoin (__{total:,.2f}__ satoshi) or __${ usd(total):,.2f}__")
        #output.put_markdown(f"- The average time to mine a block is __" + "ZZZ" + "__ minutes since the last adjustment, so the difficulty might " + move + " at next adjustment")
        #output.put_markdown(f"- The Bitcoin network hashrate is estimated to be __" + f'{ns.estimated_hashrate:,.0f}' + "__ terahashes (__" + f'{ns.estimated_hashrate/ MEGAHASH:,.1f}' + "__ exahash)") # a terahash multiplied by a megahash is an exahash... who knew
        #output.put_markdown("- Current difficulty is __" + str( ns.difficulty ) + "__ and will be adjusted in __" + "XXX" + "__ blocks (YYY days)")
        #output.put_markdown("- Current difficulty is __WHOTHEFUCKCARES__ and will be adjusted in __" + "XXX" + "__ blocks (YYY days)")
        #output.put_button( 'Adjust network numbers', onclick=popup_get_stats_from_user )
        #output.put_collapse("explain this...", content=[output.put_markdown(EXPLAIN_NETWORK)])




        # output.put_row(content=[
        #     pin.put_input(name='avgfee_growth', type='number', value=0), #TODO - oooh... fancy new, future features - DADDY LIEK!
        #     output.put_button("transaction fee analysis", onclick=currencyconverter)
        # ])
        