# MICAH FULLERTON 2022
# I stand on the shoulders of giants...
# https://insights.braiins.com/en/profitability-calculator/

from faulthandler import dump_traceback
import os
import json
import threading

# FOR THE DELETE BUTTON ON THE LIST OF MINERS TABLE
from functools import partial
from turtle import pos
import urllib.request as ur

from pyparsing import col


# FAIL GRACEFULLY AND HELP THE USER
try:
    import pywebio
    from pywebio import pin
    from pywebio import output
    from pywebio import session
except:
    print("""
        you don't seem to have pywebio installed.

        This is how you fix it:

        run this: pip3 install pywebio

        if you're on MacOS you may have to run this to upgrade pip:
        #TODO
        """)
    exit(1)

try:
    import plotly.graph_objects as go
except:
    print("""
        You don't have plotly installed.
        this is how you do it.

        run this: pip3 install plotly
        """)
    exit(1)




helloo= """
==========================
WELCOME to the
  open-source
   bitcoin
    mining
     profitability
      calculator!!
"""

#>> Welcome to my Open-Source Bitcoin Mining Profitability Calculator!!!
CLI_HELPTEXT = """
>> Remember: Ctrl-C to exit
"""

WEBSITES_THAT_HELPED = """
- https://mutuallyassuredpreservation.com/
- https://insights.braiins.com/en
- https://www.blockchain.com/api/blockchain_api
- https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp
- https://jsapi.apiary.io/apis/blockchaininfo/reference/simple-real-time-data/total-bitcoin/get.html
- https://pywebio.readthedocs.io/en/latest/guide.html
- https://github.com/bitcoin/bitcoin/blob/0.21/src/validation.cpp#L1236-L1247
- https://github.com/bitcoin/bitcoin/blob/0.21/src/chainparams.cpp#L69
- https://www.aniccaresearch.tech/blog/the-intelligent-bitcoin-miner-part-i
- https://www.blockchain.com/api/blockchain_api
"""

TEXT_WHAT_IS_MINING = """
Bitcoin transactions are approved through the process of mining. Mining requires work in the form of electricity and computation. Doing the work necessary for mining returns value to you in the form of satoshi's - the smallest unit of bitcoin.
"""

MAIN_TEXT = """# Open-Source Bitcoin Mining Profitability Calculator

__The goal of this project is to inspire__ people to learn more about bitcoin's built-in incentive structure - mining.
"""
EXPLAIN_NETWORK = """
nothing yet
"""
EXPLAIN_REWARD = """
nothing yet
"""
EXPLAIN_EXPENSE = """
nothing yet
"""
EXPLAIN_PROFITLOSS = """
"A successful miner is able to produce Bitcoin at a cost lower than the spot price, and can accordingly build a position at a steep discount compared to purchasing on the open market." [https://www.aniccaresearch.tech/blog/the-intelligent-bitcoin-miner-part-i]

It's OK if you're not making a profit! By using the heat generated by your mining equipment you can replace or suppliment other heating equipment and reduce your overall heating costs.  
"""

USER_STRATEGY_1 = 'sell only to cover expenses'
USER_STRATEGY_2 = 'HODL all'
USER_STRATEGY_3 = 'sell all'
#USER_STRATEGY_4 = 'sell to cover expense and give me X extra'

HASH     = 1 # such tiny
KILOHASH = 1_000
MEGAHASH = 1_000_000
GIGAHASH = 1_000_000_000
TERAHASH = 1_000_000_000_000
PETAHASH = 1_000_000_000_000_000
EXAHASH  = 1_000_000_000_000_000_000 # Stop ser, I'm blushing...

# number of satoshi in one bitcoin
ONE_HUNDRED_MILLION = 100_000_000

# == 144 (6 blocks per hour, for 24 hours - assuming a perfect cadence of 10 minutes per block)
EXPECTED_BLOCKS_PER_DAY = 24 * 6

# number of blocks until subsidy halves again
# https://github.com/bitcoin/bitcoin/blob/0.21/src/chainparams.cpp#L69
SUBSIDY_HALVING_INTERVAL = 210_000

### DEFAULT NUMBERS FOR THE USER INPUT FIELDS
DEFAULT_POOL_FEE = 0 # per-cent (2 == 2%; 0.1 == 0.1%) #TODO change back
DEFAUL_KPKWH = 0.075 # dollars # TODO CHANGE BACK
DEFAULT_OPEX = 15 # dollars

DEFAULT_PROJECTIONTIMELINE = 24
DEFAULT_PRICEGROW = 2
DEFAULT_HASHGROW = 3
DEFAULT_THRESHOLD = 1000000


# [ EVERY MONTH ]
KEY_ESTIMATED_HEIGHT = 'height'
KEY_ESTIMATED_NETWORK_HASHRATE = 'network hashrate'
KEY_ESTIMATED_PRICE = 'price btc'
KEY_ESTIMATED_AVGFEE = 'avgfee'

KEY_SATS_EARNED = 'earned'
KEY_SATS_SOLD = 'sold'
#KEY_SATS_HODLD = 'hodld'

KEY_COST_ELECTRICITY = 'electricity'
KEY_COST_LOAN = 'loan'
KEY_COST_OPERATING = 'operating'
KEY_COST_POOLFEE = 'poolfee'

# CONSTANTS
KEY_HASH_GROWTH = 'hash growth'
KEY_PRICE_GROWTH = 'price growth'




def block_subsity( height ):
    return (50 * ONE_HUNDRED_MILLION) >> (height // SUBSIDY_HALVING_INTERVAL)


###################
class userState:
    miners = []

    def total_wattage(self):
        w = 0
        for m in self.miners:
            w += m["wattage"] * m["quantity"]
        return w
    def total_capex(self):
        c = 0
        for m in self.miners:
            c += m["cost"] * m["quantity"]
        return c
    def total_terahash(self):
        t = 0
        for m in self.miners:
            t += (m["hashrate"]) * m["quantity"]
        return t
#####################
class networkState:
    #def __init__(self):
    price_bitcoin = 0 # in dollars
    price_satoshi = 0
    block_height = 0
    block_subsidy = 0
    fee_average = 0
    estimated_hashrate = 0

    #difficulty = []
    #qdiffstep = 10 # nblocks that we query difficulty
    #TODO  can you calculate the range of network hashrate that will produce a good average block time?

    #def update(self, price, height, avg_fee, diff, nethashps):
    def update(self, price, height, avg_fee, nethashps):
        """
            # #TODO - find again this reference.. intel' b' miner?
            # network_terahashrate + your_terahashrate / your_terahashrate
        """
        self.price_bitcoin = price
        self.price_satoshi : float = self.price_bitcoin / ONE_HUNDRED_MILLION
        self.block_height = height
        #https://github.com/bitcoin/bitcoin/blob/0.21/src/validation.cpp#L1236-L1247
        self.block_subsidy = block_subsity( self.block_height ) #(50 * ONE_HUNDRED_MILLION) >> (self.block_height // SUBSIDY_HALVING_INTERVAL)
        self.fee_average = avg_fee
        #self.difficulty = diff
        self.estimated_hashrate = nethashps

    def blocks_until_next_halvening(self):
        """
            - this is calculated off of current block height - easy.
            # TODO - where did I get this? insights source code?
        """
        return ((self.block_height // SUBSIDY_HALVING_INTERVAL + 1) * SUBSIDY_HALVING_INTERVAL) - self.block_height
##########################################################################################################################



# THE GLOBAL VARIABLES - instantiate the singularities! <3 <3
us = userState()
ns = networkState()

# TODO - DEBUG ONLY
#us.miners.append({"name":"S9","wattage":999,"hashrate":12,"cost":500,"quantity":1})






def blocks_until_halvening(block_height):
    return ((block_height // SUBSIDY_HALVING_INTERVAL + 1) * SUBSIDY_HALVING_INTERVAL) - block_height


def useful_node():
    """
        returns node path if node is (1) found, (2) running, (3) up-to-date - no in IDB

        returns None on error
    """

    bin_path = os.popen("which bitcoin-core.cli").read().strip('\n')
    if bin_path == '':
        bin_path = os.popen("which bitcoin-cli").read().strip('\n')
        if bin_path == '':
            print("ERROR: could not find bitcoin core")
            return None

    print("bitcoin core found at:", bin_path)

    try:
        # TODO provide link to docs
        #node_info = json.loads( os.popen(f"{bin_path} getblockchaininfo").read() )
        # stderr is thrown away... I'm going to tell the 
        node_info = json.loads( os.popen(f"{bin_path} getblockchaininfo 2> /dev/null").read() )

        ibd = bool( node_info['initialblockdownload'] )
        progress = float( node_info['verificationprogress'] )
    except:
        print("ERROR: your bitcoin node is not running.")
        return None

    print(node_info)

    if ibd == True:
        print(f"ERROR: your node is currently downloading the blockchain, it does not have a full copy yet ({float(progress * 100):.0f}% downloaded)")
        return None

    print(f">> your node appears up-to-date")

    return bin_path


def node_blockheight(bcli_path) -> int:
    """
    this will run bitcoin-cli at the supplied path
    TODO - provide link to bitcoin documentatiopn of 'getblockcount'
    """
    return int(os.popen(f"{bcli_path} getblockcount").read())


def node_blockhash(bcli_path, height) -> int:
    """
        TODO - I need a link to bitcoin documentation here
    """
    return os.popen(f"{bcli_path} getblockhash {height}").read()


def node_networkhashps(bcli_path, nblocks=120, height=-1) -> float: # use -1 for nblocks to go since last diff change
    """
    """
    # https://developer.bitcoin.org/reference/rpc/getnetworkhashps.html
    nh = os.popen(f"{bcli_path} getnetworkhashps {nblocks} {height}").read()
    return float( nh.split('\n')[0] )


def node_avgblockfee(bcli_path, nBlocks = EXPECTED_BLOCKS_PER_DAY) -> int:
    """
    """
    blockheight = int(os.popen(f"{bcli_path} getblockcount").read())

    output.put_text(f"Calculating average block fee from last {nBlocks} blocks - please wait...", scope='init')

    total_fee = 0
    for bdx in range(blockheight-nBlocks, blockheight):
        block_fee = int( os.popen(f"""{bcli_path} getblockstats {bdx} '["totalfee"]'""").read().split(': ')[1].split('\n')[0] )        
        total_fee += block_fee
        output.put_markdown(f"```block: {bdx} --> fee: {block_fee:,}```", scope='init')
        #output.scroll_to(scope="init", position="bottom")

    total_fee /= nBlocks

    return total_fee





def usd(satoshi, price=None):# , btc_price: float=ns.price_bitcoin):
    if price != None:
        return satoshi * (price / ONE_HUNDRED_MILLION)
    else:
        return satoshi * (ns.price_bitcoin / ONE_HUNDRED_MILLION)

# def btc(dollars): #, sat_price: float=ns.price_satoshi):
#     return dollars / ns.price_satoshi

def btc(dollars, price=None): #, sat_price: float=ns.price_satoshi):
    if price != None:
        return int(ONE_HUNDRED_MILLION * (dollars / price))
    else:
        return int(dollars / ns.price_satoshi)










# https://www.blockchain.com/api/blockchain_api
# https://blockchain.info/rawblock/<block_hash> _OR_ https://blockchain.info/rawblock/<block_hash>?format=hex
def get_average_block_fee_from_internet(nBlocks = EXPECTED_BLOCKS_PER_DAY) -> int:
    """
    """
    # TODO - USE A TRY EXCEPT BLOCK... OR ELSE FUCK FUCK FUCK.. ALSO JUST RETURN 0 AND ALERT THE USER WITH OUTPUT.TOAST
    latest_hash = str(ur.urlopen(ur.Request('https://blockchain.info/q/latesthash')).read(),'utf-8')
    total_fee = 0
    for _ in range(0, nBlocks):
        block_data = str(ur.urlopen(ur.Request(f'https://blockchain.info/rawblock/{latest_hash}')).read())
        block_fee = int(block_data.split('"fee":')[1].split(',')[0])
        height = int(block_data.split('"height":')[1].split(',')[0])
        total_fee += block_fee
        #output.put_markdown(f"```block: {height} --> fee: {block_fee:,}```", scope='init')
        block_height = int(block_data.split('"block_index":')[1].split(',')[0])
        latest_hash = block_data.split('"prev_block":')[1].split(',')[0].strip('"')
        print("block: ", block_height, " -->  fee: ", format(block_fee, ',').rjust(11), " satoshi")

    total_fee /= nBlocks
    print(f"Average fee per block in last {nBlocks} blocks:", f'{total_fee:,.0f}')
    return total_fee




#API_URL = 'https://api.coindesk.com/v1/bpi/currentprice.json'
# float( data['bpi']['USD']['rate_float'] )
#price = float( data["data"]["amount"].split(".")[0].replace(',', '') )
#price = data["data"]["amount"].replace(',', '')
def query_bitcoinprice() -> float:
    """
        - queries the current bitcoin price from the coindesk.com API

        - returns (-1) on error

        - shell one-liner:
            - alias btcprice = "curl -s 'https://api.coinbase.com/v2/prices/spot?currency=USD' | jq -r '.data.amount'"
    """

    try:
        API_URL = 'https://api.coinbase.com/v2/prices/spot?currency=USD'
        response = ur.urlopen(ur.Request( API_URL )).read()
        data = json.loads(response) # returns dict
        price = float( data['data']['amount'] )
    except:
        return -1

    return price








def user_cost_kWh() -> float:
    if pin.pin['costkwh'] == None:
        return None # TODO WHY DID I DO THIS?
    return pin.pin['costkwh']

def user_pool_fee() -> float:
    if pin.pin['poolfee'] == None:
        return None # TODO WHY DID I DO THIS?
    return pin.pin['poolfee'] / 100

def user_opex() -> int:
    if pin.pin['opex'] == None:
        return None # TODO WHY DID I DO THIS?
    return pin.pin['opex']










##############################
def currencyconverter():
    def updateprice():
        pin.pin['price'] = query_bitcoinprice()

    def convert_to_sat():
        amnt = float(pin.pin["amount"])
        price = float(pin.pin["price"])
        r = float(ONE_HUNDRED_MILLION * (amnt / price))
        pin.pin["result"] = f"${amnt:,.2f} @ ${price:,.2f} = {r:.2f} sats / {r / ONE_HUNDRED_MILLION:.2f} bitcoin\n" + pin.pin['result']

    def convert_to_usd():
        amnt = float(pin.pin["amount"])
        price = float(pin.pin["price"])
        r = amnt * (price / ONE_HUNDRED_MILLION)
        pin.pin["result"] = f"{amnt:,.2f} sats @ ${price:,.2f} = ${r:,.2f}\n" + pin.pin['result']

    output.popup('USD - BTC converter', content=[
        output.put_row(content=[
            output.put_column(content=[
                pin.put_input("price", type="float", label="Price of bitcoin:", value=query_bitcoinprice()),
                output.put_button("refresh price", onclick=updateprice)
                ]),
            output.put_column(content=[
                pin.put_input("amount", type="float", label="Amount to convert"),
                output.put_column(content=[
                    output.put_button("sats -> dollars", onclick=convert_to_usd),
                    output.put_button("dollars -> sats", onclick=convert_to_sat)
                    ])
                ])
        ]),
        pin.put_textarea("result", label="Result:", value="", readonly=True)
    ], closable=True)


###################################### THIS FUNCTION ROCKS!!!!!!!!! SAVE THIS!!!!!!!
def popup_input(pins, names, title):
    """
        Show a form in popup window.
        :param list pins: pin output list.
        :param list pins: pin name list.
        :param str title: model title.
        :return: return the form as dict, return None when user cancel the form.
    """
    if not isinstance(pins, list):
        pins = [pins]

    event = threading.Event()
    confirmed_form = None

    def onclick(val):
        nonlocal confirmed_form
        confirmed_form = val
        event.set()

    pins.append(output.put_buttons([
        {'label': 'Submit', 'value': True},
        {'label': 'Cancel', 'value': False, 'color': 'danger'},
    ], onclick=onclick))
    output.popup(title=title, content=pins, closable=False)

    event.wait()
    output.close_popup()
    if not confirmed_form:
        return None

    return {name: pin.pin[name] for name in names}



##########################
def add_miner_dialog():
    """
        THIS MAKES THE POPUP APPEAR AND BLOCKS (waits for user input before continuuing execution)
    """
    result = popup_input([
        pin.put_input('name', label='name', value='S19'),
        pin.put_input('wattage', label='wattage', type="number", value=3010),
        pin.put_input('hashrate', label='hashrate (in terahashes)', type="float", value=90),
        pin.put_input('cost', label='cost', type="float", value=18220338.98),
        pin.put_radio("units", label='cost unit', options=["bitcoin", "fiat"], value='bitcoin'),
        pin.put_input('quantity', label='quantity', type="number", value=1)
    ], names=['name', 'wattage', 'hashrate', 'cost', 'units', 'quantity'], title="Enter the details of your miner")

    # USER HIT CANCEL
    if result == None:
        return

    # VERIFY USER INPUT
    if result['name'] == None or len(result['name']) > 50:
        output.toast("invalid name - no miners added")
        return
    if result['wattage'] == None or result['wattage'] <= 0:
        output.toast("invalid wattage - no miners added")
        return
    if result['hashrate'] == None or result['hashrate'] <= 0:
        output.toast("invalid hashrate - no miners added")
        return
    if result['cost'] == None or result['cost'] <= 0:
        output.toast("invalid cost - no miners added")
        return
    if result['units'] == 'fiat':
        output.toast("Note: the cost of the miner will be converted from fiat (dollars) to satoshi using current price data", color='warn', duration=7)
        #result['cost'] = btc( result['cost'], sat_price=ns.price_satoshi )
        result['cost'] = btc( result['cost'] )

    if result['quantity'] == None or result['quantity'] <= 0:
        output.toast("invalid quantity - no miners added")
        return

    del result['units']

    # ADD THE MINER
    us.miners.append( result )

    # NOTIFY USER OF SUCCESS
    #t = "ADDED:  " + str(result['name']) + "  wattage: " + str(result['wattage']) + "  hashrate: " + str(result['hashrate']) + "   quantity: " + str(result['quantity'])
    #output.toast(t, duration=7, color='success')
    output.toast('miner added', color='success', duration=1)

    show_miners_list()
    show_results()
    show_settings()
    show_projection()

############################
def delete_miner( row ):
    del us.miners[ row ]
    output.toast("miner removed", duration=3, color='warn')

    #show_overhead()
    show_miners_list()
    show_results()
    show_settings()
    show_projection()

####################
def show_miners_list():

    if ns.block_height == 0:
        return

    with output.use_scope( 'mine', clear=True):
        output.put_markdown('# YOUR MINING EQUIPMENT')

        if len(us.miners) > 0:
            # SHOW TABLE OF MINERS
            for idx, m in enumerate(us.miners):
                output.put_table([[
                    output.put_button(['delete'], onclick=partial(delete_miner, row=idx), color='danger'),
                    output.put_text( "name:\n" + str(m['name']) ),
                    output.put_text( "wattage:\n" + str(m['wattage']) ),
                    output.put_text( "hashrate:\n" + str(m['hashrate']) ),
                    output.put_text( f"cost:\nsats: {float(m['cost']):,.2f}\nbtc: {float(m['cost']) / ONE_HUNDRED_MILLION:.2f}\n${usd(float(m['cost'])):,.2f}"),
                    output.put_text( "quantity:\n" + str(m['quantity']) )
                    ]])
        else:
            output.put_markdown("use the __ADD MINER__ button to add your miners")

        output.put_button( 'ADD MINER', onclick=add_miner_dialog )

#############################
def show_overhead():
    with output.use_scope('overhead', clear=True):
        # if len(us.miners) == 0:
        #     return

        # don't know this if network stats are unknown
        # TODO - find a better way to do this
        # if ns.block_height == 0:
        #     return

        output.put_markdown('# YOUR OVERHEAD')

        # COST PER KWH INPUT FIELD
        output.put_row(content=[
            output.put_text('your cost per kilowatt-hour: $'),
            pin.put_input('costkwh', type='float', value= DEFAUL_KPKWH),
            output.put_button("Update", onclick=recalculate)
        ])

        # POOL FEE INPUT FIELD
        output.put_row(content=[
            output.put_text('fee your mining pool charges you: %'),
            pin.put_input('poolfee', type='float', value= DEFAULT_POOL_FEE),
            output.put_button("Update", onclick=recalculate)
        ])

        # OPEX INPUT FIELD
        output.put_row(content=[
            output.put_text('monthly operational cost: $'),
            pin.put_input('opex', type='float', value= DEFAULT_OPEX),
            output.put_button("Update", onclick=recalculate)
        ])

#########################
def show_network():
    # don't know this if network stats are unknown
    if ns.estimated_hashrate == 0:
        return

    with output.use_scope('network', clear=True):
        total = ns.block_subsidy + ns.fee_average
        # if 1:
        #     move = "increase"
        # else:
        #     move = "decrease"
        output.put_markdown('# BITCOIN NETWORK STATUS')
        output.put_markdown(f"- One Bitcoin is priced at __${ns.price_bitcoin:,}__ and one satoshi is worth __${ns.price_satoshi:.5f}__")
        output.put_markdown(f"- There have been __{ns.block_height:,}__ blocks mined and the next halvening is in __{ns.blocks_until_next_halvening():,}__ blocks (__{ns.blocks_until_next_halvening()/144:.1f}__ days)")
        output.put_markdown(f"- The current block reward is __{(ns.block_subsidy / ONE_HUNDRED_MILLION)}__ bitcoin (__{ns.block_subsidy:,}__ satoshi)")
        output.put_markdown(f"- Transactions fees average __{ns.fee_average/ONE_HUNDRED_MILLION:,.3f}__ bitcoin (__{ns.fee_average:,.0f}__ satoshi) per block in the last 24 hours")
        output.put_markdown(f"- This makes the average total reward __{total/ONE_HUNDRED_MILLION:.2f}__ bitcoin (__{total:,.2f}__ satoshi) or __${ usd(total):,.2f}__")
        #output.put_markdown(f"- The average time to mine a block is __" + "ZZZ" + "__ minutes since the last adjustment, so the difficulty might " + move + " at next adjustment")
        output.put_markdown(f"- The Bitcoin network hashrate is estimated to be __" + f'{ns.estimated_hashrate:,.0f}' + "__ terahashes (__" + f'{ns.estimated_hashrate/ MEGAHASH:,.1f}' + "__ exahash)") # a terahash multiplied by a megahash is an exahash... who knew
        #output.put_markdown("- Current difficulty is __" + str( ns.difficulty ) + "__ and will be adjusted in __" + "XXX" + "__ blocks (YYY days)")
        #output.put_markdown("- Current difficulty is __WHOTHEFUCKCARES__ and will be adjusted in __" + "XXX" + "__ blocks (YYY days)")
        output.put_button( 'Adjust network numbers', onclick=get_stats_from_user )
        #output.put_collapse("explain this...", content=[output.put_markdown(EXPLAIN_NETWORK)])

###########################
def show_results():
    
    with output.use_scope('results', clear=True):
        if len(us.miners) == 0:
            return

        # THIS IS ALL WE ARE AFTER.......................
        reward = ns.block_subsidy + ns.fee_average
        share = us.total_terahash() / ns.estimated_hashrate
        rawreward = share * reward
        s10 = rawreward * (1 - user_pool_fee())
        value = usd( s10 )
        kWh = us.total_wattage() / 6000
        cost = user_cost_kWh() * kWh
        ppps = int(cost / s10 * ONE_HUNDRED_MILLION) #price paid per satoshi
        discount = int((1 - (ppps / ns.price_bitcoin)) * 100)

        output.put_markdown('# INSTANT PROFIT / LOSS')
        
        output.put_markdown('## EARNINGS')
        output.put_markdown("- Your Bitcoin miners contribute __" + f'{share:,.10f}' + "%__ of the total network hash rate")
        output.put_markdown("- Every 10 minutes you should earn an average of __" + f'{rawreward:,.0f}' + "__ satoshi / __$" + f'{ usd(rawreward):,.3f}' + "__")
        output.put_markdown("- Subtract a " + f'{user_pool_fee() * 100:,.2f}' + "% pool fee of " + f'{user_pool_fee() * rawreward:,.0f}' + " satoshi leaves __" + f'{s10:,.0f}' + "__ satoshi / __$" + f'{ usd(s10):,.3f}' + "__") #WARNING.. ROUNDING BY INT CAST
        output.put_markdown("- This will earn __$" + f'{value*EXPECTED_BLOCKS_PER_DAY:,.2f}' + "__ every day / __$" + f'{value*EXPECTED_BLOCKS_PER_DAY*30:,.2f}' + "__ every month")
        #output.put_collapse("explain this...", content=[output.put_markdown( EXPLAIN_REWARD )])

        output.put_markdown('## COST OF PRODUCTION')
        output.put_markdown("- Every 10 minutes you use __" + f'{kWh:,.3f}' + "__ kilowatt-hours, which costs __$" +f'{cost:,.2f}' + "__")
        output.put_markdown("- This will cost __$" +f'{(cost * EXPECTED_BLOCKS_PER_DAY):,.2f}' + "__ every day / __$" + f'{(cost * EXPECTED_BLOCKS_PER_DAY * 30):,.2f}' + "__ every month")
        #output.put_collapse("explain this...", content=[output.put_markdown( EXPLAIN_EXPENSE )])

        output.put_markdown('## PROFIT / LOSS')
        if value > cost:
            word = 'profit'
            output.put_markdown("You are currently getting a __" + f'{discount}' + "%__ discount by mining")
        else:
            word = 'loss'
            output.put_markdown("You are currently paying a premiun to mine bitcoin.  Turn off your miners and buy bitcoin instead, unless you are taking advantage of the heat your machines put off.")
        
        output.put_markdown("Your net " + word + " to mine per day: __$" + f'{(value-cost)*EXPECTED_BLOCKS_PER_DAY:,.2f}' + "__ / month: __$" + f'{(value-cost)*EXPECTED_BLOCKS_PER_DAY*30:,.2f}' + "__")
        output.put_markdown("Your \'instant\' cost to mine one bitcoin is __$" + f'{ppps:,}' + "__ versus a market price of __$" + f'{ns.price_bitcoin:,}' + "__")
        #output.put_collapse("explain this...", content=[output.put_markdown( EXPLAIN_PROFITLOSS )])




##########################
def pretty_graph(res):
    """
        this takes the projection results and returns a pretty graph
    """
    fig = go.Figure()
    # fig.add_trace(
    #     go.Scatter(
    #         x=[*range( len(res['earned sats']) )],
    #         y=res['earned sats'],
    #         name="earned sats"
    #     ))

    fig.add_trace(
        go.Scatter(
            x=[*range( len(res[KEY_ESTIMATED_NETWORK_HASHRATE]) )],
            # this magic just takes each element and divides..
            # so the units are now exahash and the numbers on the graph are such the more prettier...mmm ok?
            y=[e / MEGAHASH for e in res[KEY_ESTIMATED_NETWORK_HASHRATE]],
            name="network hashrate"
        ))
    # fig.add_trace(
    #     go.Bar(
    #         x=[*range( len(res['sats sold']) )],
    #         y=res['sats sold'],
    #         name="sats sold"
    #     ))

    fig.update_layout(barmode='stack')
    return fig.to_html(include_plotlyjs="require", full_html=False)

def hashfuck( v: float ):
    pin.pin['hashgrow'] = round(v, 2)
    show_projection()

def pricefuck( v: float ):
    pin.pin['pricegrow'] = round(v, 2)
    show_projection()

##########################
def show_graph(res):
    with output.use_scope("graph", clear=True):
        output.put_html( pretty_graph(res) )

##########################
def show_table(res):
    verbose = bool(pin.pin['verbose'])

    print("verbose:", verbose)
    # https://docs.python.org/3/library/string.html

# 1       2              3                             4
    str_table = """
| month | block height | network hashrate (exahash) | btc price |
| :--- | ---: | ---: | ---: |
"""
# 1       2      3      4   


                            #    1    2    3    4 
    str_table_row_format = """| %s | %s | %s | %s |"""

# KEY_ESTIMATED_HEIGHT : [],
# KEY_ESTIMATED_NETWORK_HASHRATE : [],
# KEY_ESTIMATED_PRICE : [],
# KEY_ESTIMATED_AVGFEE : [],
# KEY_ESTIMATED_REWARD
# KEY_SATS_EARNED : [],
# KEY_SATS_SOLD : [],
# KEY_SATS_HODLD : [],
# KEY_COST_ELECTRICITY : [],
# KEY_COST_LOAN : [],
# KEY_COST_OPERATING : [],
# KEY_COST_POOLFEE : [],

    for mdx in range(len(res[KEY_ESTIMATED_HEIGHT])):
        str_table += str_table_row_format % ( \
            f"{mdx + 1}",
            f"{res[KEY_ESTIMATED_HEIGHT][mdx]:,}",
            f"{res[KEY_ESTIMATED_NETWORK_HASHRATE][mdx]/MEGAHASH:,.2f}",
            f"{res[KEY_ESTIMATED_PRICE][mdx]:,.2f}",
        )
        str_table += '\n'
    
    # TODO - THE STORY
    # story = "Your strategy is to " + pin.pin['strategy'] + ".  "
    # story += "This means, once you have earned " + str(selling_threshold) + " sats, your can withdrawal them from your mining pool and sell or hold on to them.  "

    # total = str(int(_cost_electricity[0] + _cost_operating[0]))

    # if pin.pin['strategy'] == USER_STRATEGY_1:
    #     story += "You've decided to sell only enough sats to cover the $" +  total + " monthly expenses you have."

    # if pin.pin['strategy'] == USER_STRATEGY_2:
    #     story += "You've decided to not sell your bitcoin.  You are going to HODL.  So when it comes to the monthly expense... how will you pay your monthly bills of $" + total + "?..."  

    # if pin.pin['strategy'] == USER_STRATEGY_3:
    #     story += "You've decided to sell ALL the bitcoin you withdrawal and roll in stead money coming your way."

    with output.use_scope("table", clear=True):
        #output.put_text( story )
        output.put_markdown("""# Monthly Breakdown""")
        output.put_markdown( str_table )
        output.put_table(tdata=[[
                output.put_text("Download results as CSV file -->"),
                output.put_file('projection.csv', content=b'123,456,789')
            ]])


##########################
def calculate_projection(months, hashgrow, pricegrow):
    output.toast("re-calculating...", color='warn', duration=1)
    res = {
        KEY_ESTIMATED_HEIGHT : [], #HEIGHT AT THE END OF THE MONTH!
        KEY_ESTIMATED_NETWORK_HASHRATE : [], #... AT THE END OF THE MONTH!!
        KEY_ESTIMATED_PRICE : [], # ... AT THE FUCKING END OF THE MONTH... OK/!
        KEY_ESTIMATED_AVGFEE : [],
        KEY_SATS_EARNED : [],
        KEY_SATS_SOLD : [],
        #KEY_SATS_HODLD : [],
        KEY_COST_ELECTRICITY : [],
        KEY_COST_LOAN : [],
        KEY_COST_OPERATING : [],
        KEY_COST_POOLFEE : [],

        KEY_HASH_GROWTH : hashgrow,
        KEY_PRICE_GROWTH : pricegrow
    }

    _blk = ns.block_height
    _price = ns.price_bitcoin
    _nh = ns.estimated_hashrate
    for _ in range(months):

        # the monthly intermediates
        _cost_elec = 0
        #_total_poolfee = 0
        _total_earn = 0

        # DO ONE DAY OF CALCULATIONS
        for _ in range(30):

            # GO BLOCK BY BLOCK
            if blocks_until_halvening( _blk ) < EXPECTED_BLOCKS_PER_DAY:
                print("we will cross a halvening")

                for _ in range( EXPECTED_BLOCKS_PER_DAY ):

                    reward = block_subsity( _blk ) + ns.fee_average
                    rawreward = reward * us.total_terahash() / _nh

                    _total_earn += rawreward * (1 - user_pool_fee())
                    #_total_poolfee += rawreward * user_pool_fee()
                    _cost_elec += user_cost_kWh() * us.total_wattage() / 6000

                    _blk += 1

            # DO A WHOLE DAY AT A TIME
            else:
                #print("")
                #print("we will NOT cross a halvening")
                #print("calculating one day : at block ", _blk)
                #print("days until next halvening:", blocks_until_halvening(_blk ))

                reward = block_subsity( _blk ) + ns.fee_average
                rawreward = reward * us.total_terahash() / _nh

                _total_earn += rawreward * (1 - user_pool_fee()) * EXPECTED_BLOCKS_PER_DAY
                #_total_poolfee += rawreward * user_pool_fee()
                _cost_elec += 24 * user_cost_kWh() * us.total_wattage() / 1000

                _blk += EXPECTED_BLOCKS_PER_DAY

            # ONE DAY OF INCREASES
            _nh *= 1 + hashgrow / 30
            _price *= 1 + pricegrow / 30


        # END ############ DAY BY DAY

        # now we have to settle
        sell_for_electricity = btc( _cost_elec, price=_price )
        sell_for_operating = btc( user_opex(), price=_price )
        #sell_for_loan = btc( 100, price=_price )

        need_to_sell = sell_for_electricity + sell_for_operating #+ sell_for_loan

        # we have calculated the month...

        res[KEY_ESTIMATED_HEIGHT].append( _blk )
        res[KEY_ESTIMATED_NETWORK_HASHRATE].append( _nh )
        res[KEY_ESTIMATED_PRICE].append( _price )
        res[KEY_ESTIMATED_AVGFEE].append( -1 ) #TODO

        res[KEY_COST_ELECTRICITY].append(sell_for_electricity)
        res[KEY_COST_OPERATING].append(sell_for_operating)
        #res[KEY_COST_POOLFEE].append(-1)
        res[KEY_COST_LOAN].append( 0 )

        res[KEY_SATS_EARNED].append(_total_earn)
        res[KEY_SATS_SOLD].append(need_to_sell)
        #res[KEY_SATS_HODLD].append(_total_earn - need_to_sell)

    # END ################ MONTH BY MONTH

    output.toast("done.", color='success', duration=1)
    return res




##############################
def graph_play(val):
    """
        this is the callback function for the slider.
        we have to recompute everything with the new value for network hashrate growth
        then we show the graph again
    """
    
    val /= 100
    months = pin.pin['months'] / 100
    pricegrow = pin.pin['pricegrow'] / 100

    #TODO SANITIZE all these below.. do a better job
    if None in [months, pricegrow]:
        output.toast("missing projection parameters...")
        return

    res = calculate_projection(months, val, pricegrow)
    show_graph(res)




###############################
def show_projection():
    """
        This shows the input fields for the projection
        Then it calculates the projection
        Then it shows the table and graph
        Aww yis
    """
    # TODO find a better way
    # if ns.block_height == 0:
    #     return

    if len(us.miners) < 1:
        output.toast("You have no miners", color='error')
        output.clear('graph')
        output.clear('projection')
        output.clear('table')
        return

    months = pin.pin['months']
    hashgrow = pin.pin['hashgrow'] / 100
    pricegrow = pin.pin['pricegrow'] / 100
    #selling_threshold = pin.pin['threshold']

    #TODO SANITIZE INPUT - do a better job
    if None in [months, pricegrow, hashgrow]:
        output.toast("missing projection parameters...")
        return

    res = calculate_projection(months, hashgrow, pricegrow)

    # PRINT EVERYTHING TO THE SCREEN...
    with output.use_scope('projection', clear=True):
        output.put_markdown( "# PROJECTION SUMMARY:" )

# KEY_ESTIMATED_HEIGHT : [],
# KEY_ESTIMATED_NETWORK_HASHRATE : [],
# KEY_ESTIMATED_PRICE : [],
# KEY_ESTIMATED_AVGFEE : [],
# KEY_SATS_EARNED : [],
# KEY_SATS_SOLD : [],
# KEY_SATS_HODLD : [],

# KEY_COST_ELECTRICITY : [],
# KEY_COST_LOAN : [],
# KEY_COST_OPERATING : [],
# KEY_COST_POOLFEE : [],

        total_earned = 0
        for i in res[KEY_SATS_EARNED]:
            total_earned += i

        total_equipment = us.total_capex()

        total_opex = 0
        for i in res[KEY_COST_OPERATING]:
            total_opex += i
        
        total_elec = 0
        for i in res[KEY_COST_ELECTRICITY]:
            total_elec += i

        total_loan = 0
        for i in res[KEY_COST_LOAN]:
            total_loan += i

        #total_sold = us.total_capex()
        total_sold = 0
        for i in res[KEY_SATS_SOLD]:
            total_sold += i
        
        total_hodld = total_earned - total_sold - total_equipment

        ending_price = res[KEY_ESTIMATED_PRICE][-1]
        output.put_table([
                ["initial investment", f"{total_equipment :,.2f} sats on equipment"],
                ["you will sell", f"{total_elec :,.2f} sats - electricity"],
                ["you will sell", f"{total_opex :,.2f} sats - operating"],
                ["you will sell", f"{total_loan :,.2f} sats - loans"],
                ["TOTAL sold", f"{total_sold :,.2f} sats"],
                ["TOTAL", f"{total_sold + total_equipment:,.2f} sats"],
                ['---', ''],
                ["you will earn", f"{total_earned:,.2f} sats"],
                ["you will HODL", f"{total_hodld:,.2f} sats / ${usd(total_hodld, price=ending_price):,.2f}"],
            ])

    show_graph(res)
    show_table( res )

#######################
def show_settings():
    with output.use_scope("settings", clear=True):
        if len(us.miners) == 0:
            return

        output.put_markdown("# PROJECTED EARNINGS")
        pin.put_checkbox('verbose', options=['VERBOSE MODE - (put every variable on the spreadsheet)'], inline=True)

        # MONTHS
        output.put_row(content=[
            output.put_text('Months to project'),
            pin.put_input('months', type='float', value=DEFAULT_PROJECTIONTIMELINE)
        ])

        output.put_text("(remember: 6% = yearly doubling)")
        output.put_row(content=[
            output.put_text('Monthly hashrate growth: %'),
            pin.put_input('hashgrow', type='float', value=DEFAULT_HASHGROW, readonly=True),
            pin.put_slider("play_with_growth", value=DEFAULT_HASHGROW,min_value=-2.0, max_value=10.0, step=0.1 )
        ])
        pin.pin_on_change('play_with_growth', onchange=hashfuck, clear=False, init_run=False)

        output.put_row(content=[
            output.put_text('Monthly price growth: %'),
            pin.put_input('pricegrow', type='float', value=DEFAULT_PRICEGROW, readonly=True),
            pin.put_slider("price_growth_slider", value=DEFAULT_PRICEGROW,min_value=-10.0, max_value=20.0, step=0.1 )
        ])
        pin.pin_on_change('price_growth_slider', onchange=pricefuck, clear=False, init_run=False)
        # output.put_row(content=[
        #     output.put_text('selling threshold:   (satoshi)'),
        #     pin.put_input('threshold', type='float', value=DEFAULT_THRESHOLD)
        # ])
        # output.put_row(content=[
        #     output.put_text("selling strategy"),
        #     pin.put_select("strategy", options=[USER_STRATEGY_1, USER_STRATEGY_2, USER_STRATEGY_3], value='sell only to cover expense')
        # ])
        output.put_button( 're-calculate', onclick=show_projection )




#################################
def get_price_from_user():
    """
        This creates a pop-up that asks the user for the bitcoin price
        This is used if we were unable to download the price from the internet
    """
    result = popup_input([
        pin.put_input('price', label='bitcoin price', type='float', value=ns.price_bitcoin)
        ], names=['price'], title="What is the current bitcoin price?")

    # USER HIT CANCEL
    if result == None:
        return -1

    if result['price'] == None or result['price'] <= 0:
        output.toast("invalid price")
        return -1
    else:
        p = result['price']

    return p

########################################
def get_stats_from_internet() -> bool:
    """
        https://www.blockchain.com/api/q
    """
    output.put_text("Gathering data from blockchain.info...", scope='init')

    try:
        h = int(ur.urlopen(ur.Request('https://blockchain.info/q/getblockcount')).read())
        #d = int(float(ur.urlopen(ur.Request('https://blockchain.info/q/getdifficulty')).read()))
        nh = int(ur.urlopen(ur.Request('https://blockchain.info/q/hashrate')).read()) / 1000
        p = query_bitcoinprice() #int(float(ur.urlopen(ur.Request('https://blockchain.info/q/24hrprice')).read()))

        output.put_text("Getting average block fee from internet... please wait...!!!", scope='init')
        f = get_average_block_fee_from_internet(nBlocks=1) # TODO - DEBUG ONLY
    except:
        output.toast("Could not download network status.", color='error', duration=7)
        return False

    ns.update(price=p, height=h, avg_fee=f, nethashps=nh)
    
    return True


#####################################
def get_stats_from_user() -> bool:
    """
        this pop up asks the user for network stats
    """
    result = popup_input([
        pin.put_input('height', label='block height', type='number', value=ns.block_height),
        #pin.put_input('difficulty', label='difficulty', type='number', value=ns.difficulty),
        pin.put_input('hashrate', label='network hashrate (in terahashes)', type='float', value=ns.estimated_hashrate),
        pin.put_input('price', label='bitcoin price', type='float', value=ns.price_bitcoin),
        pin.put_input('fee', label='average fee (in satoshi)', type='float', value=ns.fee_average)
        ], names=['height', 'hashrate', 'price', 'fee'], title="Enter the current bitcoin network status")

    # USER HIT CANCEL
    if result == None:
        return False

    # VERIFY USER INPUT
    if result['height'] == None or result['height'] < 0:
        output.toast("invalid height")
        return False
    else:
        h = result['height']
    # if result['difficulty'] == None or result['difficulty'] <= 0:
    #     output.toast("invalid difficulty")
    #     return False
    # else:
        # d = result['difficulty']
    if result['hashrate'] == None or result['hashrate'] <= 0:
        output.toast("invalid hashrate")
        return False
    else:
        nh = result['hashrate']
    if result['price'] == None or result['price'] <= 0:
        output.toast("invalid price")
        return False
    else:
        p = result['price']
    if result['fee'] == None or result['fee'] <= 0:
        output.toast("invalid fee")
        return False
    else:
        f = result['fee']

    #ns.update(price=p, height=h, avg_fee=f, diff=d, est_hr=hr)
    ns.update(price=p, height=h, avg_fee=f, nethashps=nh)

    show_network()
    show_results()
    return True




#######################
def recalculate():
    """
        A RE-DRAW ALSO ENTAILS A RE-CALCAULATE!!!!!!!!!!!!!!!!!!
        This, this function.
        It simply calls all the functions that control a given scope.
        The start of each function calculates/updates the needed variables to show its contents
        # TODO - CALLED WHEN...
    """

    if user_cost_kWh() == None or user_pool_fee() == None or user_opex() == None:
        output.toast("can't leave input field blank", color='error')
        return

    show_results()
    show_projection()




#############
def main():
    session.set_env(title="bitcoin mining profitability calculator")
    print( CLI_HELPTEXT )

    # https://pywebio.readthedocs.io/en/latest/platform.html
    # https://pywebio.readthedocs.io/en/v1.2.2/guide.html#server-mode-and-script-mode
    # https://github.com/pywebio/PyWebIO/blob/dev/demos/bokeh_app.py
    # I can't believe this fucking works!!!!  Will it ever cause problems? #shrug
    t = threading.Thread(target=session.hold)
    session.register_thread(t)
    t.start()

    with output.use_scope('main', clear=True):
        output.put_markdown( MAIN_TEXT )
        #output.put_collapse("websites that I found to be helpful:", content=[output.put_markdown(WEBSITES_THAT_HELPED)])])
        output.put_collapse("TOOLS:", content=[output.put_button("USD - BTC converter", onclick=currencyconverter)], open=True)
    
    with output.use_scope('init', clear=True):

        path = useful_node()

        if path != None:
            output.put_text("Getting data from node...", scope='init')

            h = node_blockheight(path)
            f = node_avgblockfee(path, nBlocks=2)
            nh = node_networkhashps(path)
            
            output.put_text("Getting price of bitcoin...", scope='init')
            p = query_bitcoinprice()

            if p == -1:
                output.toast("Unable to download current bitcoin price from <some website>")
                p = get_price_from_user()

            ns.update(price=p, height=h, avg_fee=f, nethashps=nh)

        else:
            if not get_stats_from_internet():
                if not get_stats_from_user():
                    output.toast("FUCK... quitting")
                    exit(1)

        #us.miners.append({"name":"S19","wattage":3050,"hashrate":90,"cost":18220338,"quantity":1})
        # 18220338.98 sats

        output.clear(scope='init')
        show_network()
        show_overhead()
        show_miners_list()

#############################
if __name__ == '__main__':
    pywebio.start_server(main, port=8080, debug=True)
