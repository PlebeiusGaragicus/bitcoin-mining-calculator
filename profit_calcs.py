# MICAH FULLERTON 2022
# I stand on the shoulders of giants...
# https://insights.braiins.com/en/profitability-calculator/

# color picker
# https://htmlcolorcodes.com/color-picker/


TODO = """
[] make 'for info only' variables in res dict
- avg subsidy
- pool fee... ?


[] when there is no internet it doesn't work... WHY???
"""


import os
import json
import threading

# FOR THE DELETE BUTTON ON THE LIST OF MINERS TABLE
from functools import partial
from urllib.parse import non_hierarchical
import urllib.request as ur

from pandas import value_counts


# FAIL GRACEFULLY AND HELP THE USER
try:
    import pywebio
    from pywebio import pin
    from pywebio import output
    from pywebio import session
except ModuleNotFoundError:
    print("""
        you don't seem to have pywebio installed.

        This is how you fix it:

        run this: pip3 install pywebio

        if you're on MacOS you may have to run this to upgrade pip:
        #TODO
        """)
    exit(1)

try:
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
except ModuleNotFoundError:
    print("""
        You don't have plotly installed.
        this is how you do it.

        run this: pip3 install plotly
        """)
    exit(1)




helloo= """
==========================
WELCOME to the
  open-source
   bitcoin
    mining
     profitability
      calculator!!
"""

#>> Welcome to my Open-Source Bitcoin Mining Profitability Calculator!!!
CLI_HELPTEXT = """
>> Remember: Ctrl-C to exit
"""

WEBSITES_THAT_HELPED = """
- https://mutuallyassuredpreservation.com/
- https://insights.braiins.com/en
- https://www.blockchain.com/api/blockchain_api
- https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp
- https://jsapi.apiary.io/apis/blockchaininfo/reference/simple-real-time-data/total-bitcoin/get.html
- https://pywebio.readthedocs.io/en/latest/guide.html
- https://github.com/bitcoin/bitcoin/blob/0.21/src/validation.cpp#L1236-L1247
- https://github.com/bitcoin/bitcoin/blob/0.21/src/chainparams.cpp#L69
- https://www.aniccaresearch.tech/blog/the-intelligent-bitcoin-miner-part-i
- https://www.blockchain.com/api/blockchain_api
"""

TEXT_WHAT_IS_MINING = """
Bitcoin transactions are approved through the process of mining. Mining requires work in the form of electricity and computation. Doing the work necessary for mining returns value to you in the form of satoshi's - the smallest unit of bitcoin.
"""

MAIN_TEXT = """# Open-Source Bitcoin Mining Profitability Calculator

__The goal of this project is to inspire__ people to learn more about bitcoin's built-in incentive structure - mining.

__The purpose of this tool is to__ help bitcoin miners make the best business decisions - how much to pay for equipment and what operating environment is needed to be profitable.
"""

EXPLAIN_NETWORK = """
nothing yet
"""
EXPLAIN_REWARD = """
nothing yet
"""
EXPLAIN_EXPENSE = """
nothing yet
"""
EXPLAIN_PROFITLOSS = """
"A successful miner is able to produce Bitcoin at a cost lower than the spot price, and can accordingly build a position at a steep discount compared to purchasing on the open market." [https://www.aniccaresearch.tech/blog/the-intelligent-bitcoin-miner-part-i]

It's OK if you're not making a profit! By using the heat generated by your mining equipment you can replace or suppliment other heating equipment and reduce your overall heating costs.  
"""

USER_STRATEGY_1 = 'sell only to cover expenses'
USER_STRATEGY_2 = 'HODL all'
USER_STRATEGY_3 = 'sell all'
#USER_STRATEGY_4 = 'sell to cover expense and give me X extra'

HASH     = 1 # such tiny
KILOHASH = 1_000
MEGAHASH = 1_000_000
GIGAHASH = 1_000_000_000
TERAHASH = 1_000_000_000_000
PETAHASH = 1_000_000_000_000_000
EXAHASH  = 1_000_000_000_000_000_000 # Stop ser, I'm blushing...

# number of satoshi in one bitcoin
ONE_HUNDRED_MILLION = 100_000_000

# == 144 (6 blocks per hour, for 24 hours - assuming a perfect cadence of 10 minutes per block)
EXPECTED_BLOCKS_PER_DAY = 24 * 6

# number of blocks until subsidy halves again
# https://github.com/bitcoin/bitcoin/blob/0.21/src/chainparams.cpp#L69
SUBSIDY_HALVING_INTERVAL = 210_000

### DEFAULT NUMBERS FOR THE USER INPUT FIELDS
DEFAULT_POOL_FEE = 0 # per-cent (2 == 2%; 0.1 == 0.1%) #TODO change back
DEFAUL_KPKWH = 0.075 # dollars # TODO CHANGE BACK
DEFAULT_OPEX = 15 # dollars
DEFAULT_MONTHSTOPROJECT = 36
DEFAULT_PRICEGROW = 2
DEFAULT_LAG = 3
DEFAULT_PRICEGROW2 = 18
DEFAULT_HASHGROW = 3
DEFAULT_HASHGROW2 = -2
DEFAULT_THRESHOLD = 1000000




# THESE ARE THE NAMES OF THE 'PIN' INPUT FIELDS
# MINER DETAIL INPUT FIELDS
PIN_COST = 'cost'
PIN_WATTAGE = 'wattage'
PIN_HASHRATE = 'hashrate'
PIN_BOUGHTATPRICE = 'boughtatprice'
# bitcoin price
PIN_BTC_PRICE_NOW = 'price'
PIN_PRICEGROW = 'pricegrow'
PIN_PRICEGROW_SLIDER = 'pricegrow_slider'
PIN_PRICEGROW2_SLIDER = 'pricegrow2_slider'
PIN_LAG = 'lag'
PIN_PRICEGROW2 = 'pricegrow2'
# miner analysis
PIN_CAPEX = 'satsPerTH' # this is sats per TH
PIN_COST_SLIDER = 'cost_slider'
PIN_EFF = 'eff'
PIN_EFF_SLIDER = 'eff_slider'
PIN_SAT_PER_TH = 'satsperth'
# bitcoina network state
PIN_HEIGHT = 'height'
PIN_AVERAGEFEE = 'avgfee'
PIN_NETWORKHASHRATE = 'nh'
PIN_HASHGROW = 'hashgrow'
PIN_HASHGROW_SLIDER = 'hashgrow_slider'
PIN_HASHGROW2 = 'hashgrow2'
# PROJECTION PARAMETERS
PIN_KWH_RATE = 'costkwh'
PIN_POOLFEE = 'poolfee'
PIN_OPEX = 'opex'
PIN_MONTHSTOPROJECT = 'months'
PIN_NEVERSELL = 'neversellmachine' #hardwarehodler ;)
PIN_RESELL_UPPER ='resellupper'
PIN_RESELL_LOWER = 'reselllower'
PIN_UPPER_READONLY = 'upper_resale'
PIN_LOWER_READONLY = 'lower_resale'

OPTION_NEVERSELL = "Never sell machine"

# THESE ARE DICTIONARY ITEM NAMES FOR THE RESULTS DICT WE CALCULATE
KEY_ESTIMATED_HEIGHT = 'height'
KEY_ESTIMATED_NETWORK_HASHRATE = 'network_hashrate'
KEY_ESTIMATED_PRICE = 'price btc'
KEY_ESTIMATED_AVGFEE = 'avgfee'
# WHAT WE EARN / WHAT WE BURN
KEY_HASHVALUE = 'hv'
KEY_KWH = 'kwh'
# SATS THAT ARE SOLD TO KEEP THE BUSINESS GOING
KEY_SOLD_ELECTRICITY = 'sold_electricity'
KEY_SOLD_OPEX = 'sold_OPEX'
KEY_SOLD_CAPEX = 'sold_CAPEX'
# EXTRA ANALYSIS
KEY_BREAKEVEN_PRICE = 'BE price'
KEY_BREAKEVEN_PRICE_P20P = 'BE price 20%'
KEY_BREAKEVEN_NH = 'BE hashrate'
# THE (CONSTANT) PARAMETERS FOR THIS PROJECTION CALCULATION
KEY_HASH_GROWTH = 'hash growth'
KEY_PRICE_GROWTH = 'price growth'
KEY_START_HEIGHT = 'start height'
KEY_RATE_KWH = 'rate kwh'
KEY_CAPEX = 'capex'
KEY_OPEX = 'opex'


def block_subsity( height ):
    return (50 * ONE_HUNDRED_MILLION) >> (height // SUBSIDY_HALVING_INTERVAL)

def blocks_until_halvening(block_height):
    return ((block_height // SUBSIDY_HALVING_INTERVAL + 1) * SUBSIDY_HALVING_INTERVAL) - block_height


def useful_node():
    """
        returns node path if node is (1) found, (2) running, (3) up-to-date - no in IDB

        returns None on error
    """

    bin_path = os.popen("which bitcoin-core.cli").read().strip('\n')
    if bin_path == '':
        bin_path = os.popen("which bitcoin-cli").read().strip('\n')
        if bin_path == '':
            print("ERROR: could not find bitcoin core")
            return None

    print("bitcoin core found at:", bin_path)

    try:
        # TODO provide link to docs
        #node_info = json.loads( os.popen(f"{bin_path} getblockchaininfo").read() )
        # stderr is thrown away... I'm going to tell the 
        node_info = json.loads( os.popen(f"{bin_path} getblockchaininfo 2> /dev/null").read() )

        ibd = bool( node_info['initialblockdownload'] )
        progress = float( node_info['verificationprogress'] )
    except:
        print("ERROR: your bitcoin node is not running.")
        return None

    print(node_info)

    if ibd == True:
        print(f"ERROR: your node is currently downloading the blockchain, it does not have a full copy yet ({float(progress * 100):.0f}% downloaded)")
        return None

    print(f">> your node appears up-to-date")

    return bin_path


def node_blockheight(bcli_path) -> int:
    """
    this will run bitcoin-cli at the supplied path
    TODO - provide link to bitcoin documentatiopn of 'getblockcount'
    """
    return int(os.popen(f"{bcli_path} getblockcount").read())


def node_blockhash(bcli_path, height) -> int:
    """
        TODO - I need a link to bitcoin documentation here
    """
    return os.popen(f"{bcli_path} getblockhash {height}").read()


def node_networkhashps(bcli_path, nblocks=120, height=-1) -> float: # use -1 for nblocks to go since last diff change
    """
    """
    # https://developer.bitcoin.org/reference/rpc/getnetworkhashps.html
    nh = os.popen(f"{bcli_path} getnetworkhashps {nblocks} {height}").read()
    return float( nh.split('\n')[0] )


def node_avgblockfee(bcli_path, nBlocks = EXPECTED_BLOCKS_PER_DAY) -> int:
    """
    """
    blockheight = int(os.popen(f"{bcli_path} getblockcount").read())

    output.put_text(f"Calculating average block fee from last {nBlocks} blocks - please wait...", scope='init')

    total_fee = 0
    for bdx in range(blockheight-nBlocks, blockheight):
        block_fee = int( os.popen(f"""{bcli_path} getblockstats {bdx} '["totalfee"]'""").read().split(': ')[1].split('\n')[0] )        
        total_fee += block_fee
        output.put_markdown(f"```block: {bdx} --> fee: {block_fee:,}```", scope='init')
        #output.scroll_to(scope="init", position="bottom")

    total_fee /= nBlocks

    return total_fee





def usd(satoshi, price):
    return satoshi * (price / ONE_HUNDRED_MILLION)

def btc(dollars, price):
    return int(ONE_HUNDRED_MILLION * (dollars / price))





#################################
def popup_get_price_from_user():
    """
        This creates a pop-up that asks the user for the bitcoin price
        This is used if we were unable to download the price from the internet
    """
    result = popup_input([
        pin.put_input('price', label='bitcoin price', type='float', value=pin.pin[PIN_BTC_PRICE_NOW])
        ], names=['price'], title="What is the current bitcoin price?")

    # USER HIT CANCEL
    if result == None:
        return -1

    if result['price'] == None or result['price'] <= 0:
        output.toast("invalid price")
        return -1
    else:
        p = result['price']

    return p


#####################################
def popup_get_stats_from_user() -> bool:
    """
        this pop up asks the user for network stats
    """
    result = popup_input([
        pin.put_input('in_height', label='block height', type='number', value=pin.pin[PIN_HEIGHT]),
        #pin.put_input('difficulty', label='difficulty', type='number', value=ns.difficulty),
        pin.put_input('in_hashrate', label='network hashrate (in terahashes)', type='float', value=pin.pin[PIN_NETWORKHASHRATE]),
        pin.put_input('in_price', label='bitcoin price', type='float', value=pin.pin[PIN_BTC_PRICE_NOW]),
        pin.put_input('in_fee', label='average fee (in satoshi)', type='float', value=pin.pin[PIN_AVERAGEFEE])
        ], names=['in_height', 'in_hashrate', 'in_price', 'in_fee'], title="Enter the current bitcoin network status")

    # USER HIT CANCEL
    if result == None:
        return False

    # VERIFY USER INPUT
    if result['in_height'] == None or result['in_height'] < 0:
        output.toast("invalid height")
        return False
    else:
        h = result['in_height']
        # d = result['difficulty']
    if result['in_hashrate'] == None or result['in_hashrate'] <= 0:
        output.toast("invalid hashrate")
        return False
    else:
        nh = result['in_hashrate']
    if result['in_price'] == None or result['in_price'] <= 0:
        output.toast("invalid price")
        return False
    else:
        p = result['in_price']
    if result['in_fee'] == None or result['in_fee'] <= 0:
        output.toast("invalid fee")
        return False
    else:
        f = result['in_fee']

    # TODO clean these numbers up...?  Round them???
    pin.pin[PIN_BTC_PRICE_NOW] = p
    pin.pin[PIN_BOUGHTATPRICE] = p
    pin.pin[PIN_HEIGHT] = h
    pin.pin[PIN_AVERAGEFEE] = f
    pin.pin[PIN_NETWORKHASHRATE] = nh

    return True


########################################
def get_stats_from_internet() -> bool:
    """
        https://www.blockchain.com/api/q
    """
    output.put_text("Gathering data from blockchain.info...", scope='init')

    try:
        h = int(ur.urlopen(ur.Request('https://blockchain.info/q/getblockcount')).read())
        #d = int(float(ur.urlopen(ur.Request('https://blockchain.info/q/getdifficulty')).read()))
        nh = int(ur.urlopen(ur.Request('https://blockchain.info/q/hashrate')).read()) / 1000
        p = query_bitcoinprice() #int(float(ur.urlopen(ur.Request('https://blockchain.info/q/24hrprice')).read()))

        output.put_text("Getting average block fee from internet... please wait...!!!", scope='init')
        #f = get_average_block_fee_from_internet(nBlocks=1) # TODO - DEBUG ONLY
        f = 9_000_000 # TODO - DEBUG ONLY # TODO - DEBUG ONLY # TODO - DEBUG ONLY
    except:
        output.toast("Could not download network status.", color='error', duration=4)
        return False

    pin.pin[PIN_BTC_PRICE_NOW] = p
    pin.pin[PIN_BOUGHTATPRICE] = p
    pin.pin[PIN_HEIGHT] = h
    pin.pin[PIN_AVERAGEFEE] = f
    pin.pin[PIN_NETWORKHASHRATE] = nh

    return True
# price_bitcoin = 30_515.13
# price_satoshi = price_bitcoin / ONE_HUNDRED_MILLION
# block_height = 738_592
# block_subsidy = 6.25
# fee_average = 9_000_000
# estimated_hashrate = 227 * MEGAHASH

# self.price_bitcoin = price
# self.price_satoshi : float = self.price_bitcoin / ONE_HUNDRED_MILLION
# self.block_height = height
# #https://github.com/bitcoin/bitcoin/blob/0.21/src/validation.cpp#L1236-L1247
# self.block_subsidy = block_subsity( self.block_height ) #(50 * ONE_HUNDRED_MILLION) >> (self.block_height // SUBSIDY_HALVING_INTERVAL)
# self.fee_average = avg_fee
# #self.difficulty = diff
# self.estimated_hashrate = nethashps




# https://www.blockchain.com/api/blockchain_api
# https://blockchain.info/rawblock/<block_hash> _OR_ https://blockchain.info/rawblock/<block_hash>?format=hex
def get_average_block_fee_from_internet(nBlocks = EXPECTED_BLOCKS_PER_DAY) -> int:
    """
    """
    # TODO - USE A TRY EXCEPT BLOCK... OR ELSE FUCK FUCK FUCK.. ALSO JUST RETURN 0 AND ALERT THE USER WITH OUTPUT.TOAST
    latest_hash = str(ur.urlopen(ur.Request('https://blockchain.info/q/latesthash')).read(),'utf-8')
    total_fee = 0
    for _ in range(0, nBlocks):
        block_data = str(ur.urlopen(ur.Request(f'https://blockchain.info/rawblock/{latest_hash}')).read())
        block_fee = int(block_data.split('"fee":')[1].split(',')[0])
        height = int(block_data.split('"height":')[1].split(',')[0])
        total_fee += block_fee
        #output.put_markdown(f"```block: {height} --> fee: {block_fee:,}```", scope='init')
        block_height = int(block_data.split('"block_index":')[1].split(',')[0])
        latest_hash = block_data.split('"prev_block":')[1].split(',')[0].strip('"')
        print("block: ", block_height, " -->  fee: ", format(block_fee, ',').rjust(11), " satoshi")

    total_fee /= nBlocks
    print(f"Average fee per block in last {nBlocks} blocks:", f'{total_fee:,.0f}')
    return total_fee




#API_URL = 'https://api.coindesk.com/v1/bpi/currentprice.json'
# float( data['bpi']['USD']['rate_float'] )
#price = float( data["data"]["amount"].split(".")[0].replace(',', '') )
#price = data["data"]["amount"].replace(',', '')
def query_bitcoinprice() -> float:
    """
        - queries the current bitcoin price from the coindesk.com API

        - returns (-1) on error

        - shell one-liner:
            - alias btcprice = "curl -s 'https://api.coinbase.com/v2/prices/spot?currency=USD' | jq -r '.data.amount'"
    """

    try:
        API_URL = 'https://api.coinbase.com/v2/prices/spot?currency=USD'
        response = ur.urlopen(ur.Request( API_URL )).read()
        data = json.loads(response) # returns dict
        price = float( data['data']['amount'] )
    except:
        return -1

    return price








##############################
def currencyconverter():
    def updateprice():
        pin.pin['convertprice'] = query_bitcoinprice()

    def convert_to_sat():
        try:
            amnt = float(pin.pin["amount"])
            price = float(pin.pin["convertprice"])
            if amnt < 0 or price < 0:
                return
        except:
            return
        r = float(ONE_HUNDRED_MILLION * (amnt / price))
        pin.pin["result"] = f"${amnt:,.2f} @ ${price:,.2f} = {r:.2f} sats / {r / ONE_HUNDRED_MILLION:.2f} bitcoin\n" + pin.pin['result']

    def convert_to_usd():
        try:
            amnt = float(pin.pin["amount"])
            price = float(pin.pin["convertprice"])
            if amnt < 0 or price < 0:
                return
        except:
            return
        r = amnt * (price / ONE_HUNDRED_MILLION)
        pin.pin["result"] = f"{amnt:,.2f} sats @ ${price:,.2f} = ${r:,.2f}\n" + pin.pin['result']

    output.popup('USD - BTC converter', content=[
        output.put_row(content=[
            output.put_column(content=[
                pin.put_input("convertprice", type="float", label="Price of bitcoin:", value=query_bitcoinprice()),
                output.put_button("refresh price", onclick=updateprice)
                ]),
            output.put_column(content=[
                pin.put_input("amount", type="float", label="Amount to convert"),
                output.put_column(content=[
                    output.put_button("sats -> dollars", onclick=convert_to_usd),
                    output.put_button("dollars -> sats", onclick=convert_to_sat)
                    ])
                ])
        ]),
        pin.put_textarea("result", label="Result:", value="", readonly=True)
    ], closable=True)


def showstepbystep():
    # use 1TH and show calculation for hash value.. ETC ETC ETC
    output.toast("not implemented yet... sorry")

def feeanalysis():
    output.toast("not implemented yet... sorry")

def hashratehistory():
    # https://www.tradingview.com/
    output.toast("not implemented yet... sorry")

def pricehistory():
    # make a fucking moving average
    output.toast("not implemented yet... sorry")

###################################### THIS FUNCTION ROCKS!!!!!!!!! SAVE THIS!!!!!!!
#def popup_input(pins, names, title):
# onchangepinname='examples', onchange=changeentries)
def popup_input(pins, names, title, onchangepinname=None, callback=None):
    """
        Show a form in popup window.
        :param list pins: pin output list.
        :param list pins: pin name list.
        :param str title: model title.
        :return: return the form as dict, return None when user cancel the form.
    """
    if not isinstance(pins, list):
        pins = [pins]

    event = threading.Event()
    confirmed_form = None

    def onclick(val):
        nonlocal confirmed_form
        confirmed_form = val
        event.set()

    pins.append(output.put_buttons([
        {'label': 'Submit', 'value': True},
        {'label': 'Cancel', 'value': False, 'color': 'danger'},
    ], onclick=onclick))
    output.popup(title=title, content=pins, closable=False)
    
    if not onchangepinname == None:
        pin.pin_on_change(onchangepinname, onchange=callback)

    event.wait()
    output.close_popup()
    if not confirmed_form:
        return None

    return {name: pin.pin[name] for name in names}









##########################
def pretty_graph(res):
    """
        this takes the projection results and returns a pretty graph
    """
    #fig = go.Figure()
    fig = make_subplots(specs=[[{"secondary_y": True}]])

    fig.add_trace(
        go.Scatter(
            x=[*range( len(res[KEY_HASHVALUE]) ), res[KEY_ESTIMATED_HEIGHT]],
            #y=res[KEY_SATS_SOLD],
            # make these negative numbers... ;)
            #y=[round(e, 1) for e in res[KEY_SATS_SOLD]],
            y=res[KEY_HASHVALUE],
            name="sats earned",
            line_color="#A50CAC" # PURPLE
        ), secondary_y=False)
    fig.add_trace(
        go.Bar(
            x=[*range( len(res[KEY_SOLD_CAPEX]) )],
            #y=res[KEY_SATS_SOLD],
            # make these negative numbers... ;)
            #y=[round(e, 1) for e in res[KEY_SATS_SOLD]],
            #y=res[KEY_SOLD_OPEX],
            y=[round(e, 1) for e in res[KEY_SOLD_CAPEX]],
            name="sats sold for CAPEX",
            #color="#07A154" # GREEN
            #choropleth='#07A154'
            #https://plotly.com/python/bar-charts/#colored-bars
            #pattern_shape="nation", pattern_shape_sequence=[".", "x", "+"])
        ), secondary_y=False)
    fig.add_trace(
        go.Bar(
            x=[*range( len(res[KEY_SOLD_OPEX]) )],
            #y=res[KEY_SATS_SOLD],
            # make these negative numbers... ;)
            #y=[round(e, 1) for e in res[KEY_SATS_SOLD]],
            #y=res[KEY_SOLD_OPEX],
            y=[round(e, 1) for e in res[KEY_SOLD_OPEX]],
            name=f"sats sold for OPEX - ${DEFAULT_OPEX}",
        ), secondary_y=False)

    fig.add_trace(
        go.Bar(
            x=[*range( len(res[KEY_SOLD_ELECTRICITY]) )],
            #y=res[KEY_SATS_SOLD],
            # make these negative numbers... ;)
            #y=[round(e, 1) for e in res[KEY_SATS_SOLD]],
            #y=res[KEY_SOLD_ELECTRICITY],
            y=[round(e, 1) for e in res[KEY_SOLD_ELECTRICITY]],
            name="sats sold for ELECTRICITY"
        ), secondary_y=False)

    # CALCULATED BREAK-EVEN PRICE
    fig.add_trace(
        go.Scatter(
            x=[*range( len(res[KEY_BREAKEVEN_PRICE]) )],
            y=res[KEY_BREAKEVEN_PRICE],
            name="Break-even Bitcoin price",
            line_color="#CBDE12" # YELLOW
        ), secondary_y=True,)
    # THE PRICE WE ESTIMATE/FORECAST
    fig.add_trace(
        go.Scatter(
            x=[*range( len(res[KEY_ESTIMATED_PRICE]) )],
            y=[round(e, 1) for e in res[KEY_ESTIMATED_PRICE]],
            name="Predicted Bitcoin price",
            line_color="#12DE4D" # LIGHT GREEN
        ), secondary_y=True)

    # hodld = []
    # for i in range(len(res[KEY_SATS_EARNED])):
    #     hodld.append( round(res[KEY_SATS_EARNED][i] - res[KEY_SATS_SOLD][i], 1))

    # fig.add_trace(
    #     go.Bar(
    #         x=[*range( len(res[KEY_SATS_EARNED]) )],
    #         y=hodld,
    #         name="sats held"
    #     ))
    # # fig.add_trace(
    #     go.Scatter(
    #         x=[*range( len(res[KEY_ESTIMATED_NETWORK_HASHRATE]) )],
    #         # this magic just takes each element and divides..
    #         # so the units are now exahash and the numbers on the graph are such the more prettier...mmm ok?
    #         y=[e / MEGAHASH for e in res[KEY_ESTIMATED_NETWORK_HASHRATE]],
    #         name="network hashrate"
    #     ))

    # Set x-axis title
    fig.update_xaxes(title_text="xaxis title")

    # Set y-axes titles
    fig.update_yaxes(title_text="<b>satoshi</b>", secondary_y=False)
    fig.update_yaxes(title_text="<b>Bitcoin price</b>", secondary_y=True)

    fig.update_layout(barmode='stack')
    return fig.to_html(include_plotlyjs="require", full_html=False)





# THESE FUNCTIONS ARE CALLED BY THE SLIDER PIN CALLBACK AND ADJUST THE PIN INPUT THEY CORRESPOND
def pricegrow_slider( v: float ):
    try:
        pin.pin[PIN_PRICEGROW] = round(v, 2)
    except:
        output.toast("Price growth metric can't be blank.")
        return
    show_projection()

def pricegrow2_slider( v: float ):
    try:
        pin.pin[PIN_PRICEGROW2] = round(v, 2)
    except:
        output.toast("Post-halvening price growth metric can't be blank.")
        return
    show_projection()

def hashgrow_slider( v: float ):
    try:
        pin.pin[PIN_HASHGROW] = round(v, 2)
    except:
        output.toast("Hash growth metric can't be blank")
        return
    show_projection()

def eff_slider( v: float ):
    """
        THIS IS THE CALLBACK FOR THE SLIDER
        THE SLIDER MEASURES EFF...
            SO WHEN IT'S UPDATED WE UPDATE HASHRATE ASSUME A CONSTANT WATTAGE
    """
    try:
        hr = round(pin.pin[PIN_WATTAGE] / v, 2)
        pin.pin[PIN_HASHRATE] = hr
        pin.pin[PIN_EFF] = round(v, 2)

        usd_cost_of_miner = pin.pin[PIN_COST]
        boughtatprice = pin.pin[PIN_BOUGHTATPRICE]
        dollarsperth =  usd_cost_of_miner / hr

        if None in [usd_cost_of_miner, dollarsperth, boughtatprice]:
            pin.pin_update(PIN_SAT_PER_TH, help_text='')
            pin.pin[PIN_SAT_PER_TH] = ''
            return

        pin.pin_update(PIN_SAT_PER_TH, help_text=f"${dollarsperth:,.2f} / TH")
        pin.pin[PIN_SAT_PER_TH] = f"{round(btc(usd_cost_of_miner, price=boughtatprice) / hr, 1):,.2f}"
    except Exception as e:
        output.toast("Enter in mining equipment details first.")
        print("ERROR:", e)
        return
    #show_projection()

def hashrate_waschanged(hashrate: float):
    """
        THIS IS THE CALLBACK FOR PIN_HASHRATE ONCHANGE=
        it updates PIN_EFF and PIN_EFF_SLIDER slider
    """
    if pin.pin[PIN_WATTAGE] == None or pin.pin[PIN_WATTAGE] < 1:
        return
    if hashrate == None or hashrate < 1:
        pin.pin[PIN_EFF] = pin.pin[PIN_EFF_SLIDER] = 0
        return
    
    usd_cost_of_miner = pin.pin[PIN_COST]

    if not usd_cost_of_miner == None:
        dollarsperth = usd_cost_of_miner / hashrate
        pin.pin_update(PIN_SAT_PER_TH, help_text=f"${dollarsperth:,.2f} / TH")

    pin.pin[PIN_EFF] = pin.pin[PIN_EFF_SLIDER] = round(pin.pin[PIN_WATTAGE] / hashrate, 2)

def wattage_waschanged(wattage: float):
    """
        THIS IS THE CALLBACK FOR PIN_WATTAGE ONCHANGE=
        it updates PIN_EFF and PIN_EFF_SLIDER slider
    """
    if pin.pin[PIN_HASHRATE] == None or pin.pin[PIN_HASHRATE] < 1:
        return
    if wattage == None or wattage < 1:
        pin.pin[PIN_EFF] = pin.pin[PIN_EFF_SLIDER] = 0
        return

    pin.pin[PIN_EFF] = pin.pin[PIN_EFF_SLIDER] = round(wattage / pin.pin[PIN_HASHRATE], 1)


def cost_slider(usd_cost_of_miner: float):
    try:
        hr = float(pin.pin[PIN_HASHRATE])
        dollarsperth = usd_cost_of_miner / hr

        pin.pin_update(PIN_SAT_PER_TH, help_text=f"${dollarsperth:,.2f} / TH")
        pin.pin[PIN_COST] = round(usd_cost_of_miner, 2)

        # I don't like this... we aren't sanitizing
        upperresale_waschanged( pin.pin[PIN_RESELL_UPPER] )
        lowerresale_waschanged( pin.pin[PIN_RESELL_LOWER] )

        new_boughtatprice = float(pin.pin[PIN_BOUGHTATPRICE])
        pin.pin[PIN_SAT_PER_TH] = f"{round(btc(usd_cost_of_miner, price=new_boughtatprice) / hr, 1):,.2f}"
        pin.pin_update(name=PIN_COST, help_text=f"{ONE_HUNDRED_MILLION * (usd_cost_of_miner/new_boughtatprice):,.1f} sats")
        #pin.pin[PIN_SAT_PER_TH] = round(btc(usd_cost_of_miner, price=newprice) / hr, 1)
    except Exception as e:
        print("ERROR:", e)
        return

def boughtatprice_waschanged(newprice: float):
    if newprice == None or newprice < 1:
        pin.pin[PIN_SAT_PER_TH] = ''
        return

    try:
        usd_cost_of_miner = float(pin.pin[PIN_COST])
        hr = float(pin.pin[PIN_HASHRATE])
    except:
        pin.pin[PIN_SAT_PER_TH] = ''
        pin.pin[PIN_COST_SLIDER] = ''
        return

    pin.pin[PIN_SAT_PER_TH] = f"{round(btc(usd_cost_of_miner, price=newprice) / hr, 1):,.2f}"
    pin.pin_update(name=PIN_COST, help_text=f"{ONE_HUNDRED_MILLION * (usd_cost_of_miner/newprice):,.1f} sats")
    #pin.pin[PIN_SAT_PER_TH] = round(btc(usd_cost_of_miner, price=newprice) / hr, 1)

    # call this to adjust everything else along with it
    # adjust_cost( float(pin.pin[PIN_COST]) )

##########################
def show_graph(res):
    with output.use_scope("graph", clear=True):
        output.put_html( pretty_graph(res) )

##########################
def show_table(res):
    #verbose = bool(pin.pin['verbose'])
    #print("verbose:", verbose)


    # https://docs.python.org/3/library/string.html
# 1       2              3                             4
    str_table = """
| month | block height | network hashrate (exahash) | btc price |
| :--- | ---: | ---: | ---: |
"""
# 1       2      3      4   

                            #    1    2    3    4 
    str_table_row_format = """| %s | %s | %s | %s |"""

    for mdx in range(len(res[KEY_ESTIMATED_HEIGHT])):
        str_table += str_table_row_format % ( \
            f"{mdx + 1}",
            f"{res[KEY_ESTIMATED_HEIGHT][mdx]:,}",
            f"{res[KEY_ESTIMATED_NETWORK_HASHRATE][mdx]/MEGAHASH:,.2f}",
            f"{res[KEY_ESTIMATED_PRICE][mdx]:,.2f}",
        )
        str_table += '\n'

    # TODO - THE STORY
    # story = "Your strategy is to " + pin.pin['strategy'] + ".  "
    # story += "This means, once you have earned " + str(selling_threshold) + " sats, your can withdrawal them from your mining pool and sell or hold on to them.  "

    # total = str(int(_cost_electricity[0] + _cost_operating[0]))

    # if pin.pin['strategy'] == USER_STRATEGY_1:
    #     story += "You've decided to sell only enough sats to cover the $" +  total + " monthly expenses you have."

    # if pin.pin['strategy'] == USER_STRATEGY_2:
    #     story += "You've decided to not sell your bitcoin.  You are going to HODL.  So when it comes to the monthly expense... how will you pay your monthly bills of $" + total + "?..."  

    # if pin.pin['strategy'] == USER_STRATEGY_3:
    #     story += "You've decided to sell ALL the bitcoin you withdrawal and roll in stead money coming your way."

    with output.use_scope("table", clear=True):
        #output.put_text( story )
        #output.put_markdown("""# Monthly Breakdown""")
        
        output.put_collapse("Monthly Breakdown Table", content=[
            output.put_markdown( str_table ),
            output.put_table(tdata=[[
                    output.put_file('projection.csv', content=b'123,456,789'),
                    output.put_text("<<-- Download results as CSV file")
                ]])
        ])


##########################
 # TODO - FUTURE GENERALIZATION IMPROVEMENT@@@!!! , miner_list, network_stats):
def calculate_projection(months, height, hashrate, wattage, price, networh_hashrate, avgfee, poolfee, hashgrow, hashgrow2, pricegrow, pricegrow2, pricelag, cost_kWh, opex, capex, resale_percent):
    output.toast("re-calculating...", color='warn', duration=1)
    res = {
         #HEIGHT AT THE END OF THE MONTH!
        KEY_ESTIMATED_HEIGHT : [],
        KEY_ESTIMATED_NETWORK_HASHRATE : [],
        KEY_ESTIMATED_PRICE : [],
        KEY_ESTIMATED_AVGFEE : [],

        KEY_HASHVALUE : [],
        KEY_KWH : [],

        # BASICALLYYY.. THE RESULT
        # EXPENSE
        KEY_SOLD_ELECTRICITY : [],
        KEY_SOLD_OPEX : [],
        KEY_SOLD_CAPEX : [],

        # DECISION /FOREWARD-LOOKING // PROFIC ASSUMPTION MAKING-DECISION POINTS
        KEY_BREAKEVEN_PRICE : [],
        KEY_BREAKEVEN_PRICE_P20P : [],
        KEY_BREAKEVEN_NH : [],

        # THIS-RUN'S METRICS
        KEY_HASH_GROWTH : hashgrow,
        #KEY_HASH_GROWTH2 : hashgrow2,
        KEY_PRICE_GROWTH : pricegrow,
        #KEY_PRICE_GROWTH2 : pricegrow2,
        #KEY_PRICE_LAG : pricelag,
        # TODO _ USE THIS FOR BACKWARDS MODEL TESTING
        KEY_START_HEIGHT : height,

        # the user's decisions
        KEY_CAPEX : [], # sats
        KEY_OPEX : [],
        KEY_RATE_KWH : [],
    }

    _blk = height
    _price = price
    # NO NEED FOR THESE VARIABLES...
    _nh = networh_hashrate

    #dollar_capex = usd(capex, price=_price)
    crossed = False
    month_we_crossed = 0

    for m in range(months):
        hashvalue = 0
        poolfee = 0
        _kwh = 0

        # DO ONE DAY OF CALCULATIONS
        for _ in range(30):

            if blocks_until_halvening( _blk ) < EXPECTED_BLOCKS_PER_DAY:
                print("we will cross a halvening")
                crossed = True
                month_we_crossed = m

                # GO BLOCK BY BLOCK
                for _ in range( EXPECTED_BLOCKS_PER_DAY ):

                    #hashvalue += us.total_terahash() * (block_subsity( _blk ) + ns.fee_average) * (1 - user_pool_fee()) / _nh
                    hashvalue += hashrate * (block_subsity( _blk ) + avgfee) * (1 - poolfee) / _nh
                    #_kwh += us.total_wattage() / 6000 / us.total_terahash()
                    _kwh += wattage / 6000

                    _blk += 1

            # DO A WHOLE DAY AT A TIME
            else:
                print("we will NOT cross a halvening - calculating one day : at block ", _blk, " until:", blocks_until_halvening(_blk ))

                hashvalue += hashrate * (block_subsity( _blk ) + avgfee) * (1 - poolfee) * EXPECTED_BLOCKS_PER_DAY / _nh
                #hashvalue += (block_subsity( _blk ) + ns.fee_average) * (1 - user_pool_fee()) * EXPECTED_BLOCKS_PER_DAY / _nh
                #_kwh += 24 * us.total_wattage() / 1000 / us.total_terahash()
                _kwh += 24 * wattage / 1000

                _blk += EXPECTED_BLOCKS_PER_DAY

            # END OF DAY STUFF
            _nh *= 1 + hashgrow / 30

        # END OF MONTH STUFF - now we have to settle


        # if we have crossed the halvening AND it's been 'LAG MONTHS' since... use pricegrow2
        if crossed and m - month_we_crossed >= pricelag:
            print(f"price increased from{_price:,.2f} to ", end='')
            _price *= 1 + pricegrow2
            print(f"{_price} using growth factor2: {pricegrow2}")
        else:
            # if we haven't crossed a halvening... OR it hasn't been 'LAG MONTHS' yet
            print(f"price increased from{_price:,.2f} to ", end='')
            _price *= 1 + pricegrow # 1 + pricegrow / 30 # daily
            print(f"{_price} using growth factor: {pricegrow}")

        # TODO
        # if no profit
            # unplug
        # if duck, fuck, squeeze... print()

        sold_e = btc(_kwh * cost_kWh, price=_price)
        sold_o = btc(opex, price=_price) # we divide opex by my hashrate because everything else on this graph is reduced in this manner
        sold_c = resale_percent * capex / months #already in btc terms

        breakeven_price = 0 # WRONG

        # if sold_e + sold_o + sold_c > hashvalue:
        #     hashvalue = 0
        #     sold_e = 0
        #     sold_o = 0
        #     sold_c = 0

        res[KEY_ESTIMATED_HEIGHT].append( _blk )
        res[KEY_ESTIMATED_NETWORK_HASHRATE].append( _nh )
        res[KEY_ESTIMATED_PRICE].append( _price )
        res[KEY_ESTIMATED_AVGFEE].append( 0 )

        res[KEY_HASHVALUE].append( hashvalue )
        res[KEY_KWH].append( _kwh )

        res[KEY_SOLD_ELECTRICITY].append( sold_e )
        res[KEY_SOLD_OPEX].append( sold_o )
        res[KEY_SOLD_CAPEX].append( sold_c )

        # basically, just the decision/assumption-making/verifying helper variables
        #beprice = hashvalue * ((_kwh * cost_kWh) + (sold_c) + (opex / us.total_terahash())) / ONE_HUNDRED_MILLION
        #beprice = ((_kwh * cost_kWh) + (dollar_capex) + (opex / us.total_terahash())) / hashvalue * ONE_HUNDRED_MILLION

        res[KEY_BREAKEVEN_PRICE].append( breakeven_price )
        # KEY_BREAKEVEN_PRICE_P20P : [],
        # KEY_BREAKEVEN_NH : [],


    output.toast("done.", color='success', duration=1)
    return res








###############################
def show_projection():
    """
        THIS FUNCTION TAKES THE VALUES FROM THE INPUT FIELDS AND RUNS THE PROJECTION...
        TODO - I HAVE TO FUCKING SANITIZE THE INPUTS!!!!!!! DO IT ALL AT-ONCE HERE!
    """

    try:
        hashrate = float(pin.pin[PIN_HASHRATE])
        wattage = int(pin.pin[PIN_WATTAGE])
        capex = float(pin.pin[PIN_COST])
        opex = float(pin.pin[PIN_OPEX])
        poolfee = float(pin.pin[PIN_POOLFEE] / 100)
        rate = float(pin.pin[PIN_KWH_RATE])
    except:
        output.toast("Something went wrong - make sure you didn't leave anything blank!")
        return

    nh = float(pin.pin[PIN_NETWORKHASHRATE])

    avgfee = float(pin.pin[PIN_AVERAGEFEE])

    height = int(pin.pin[PIN_HEIGHT])
    price = float(pin.pin[PIN_BTC_PRICE_NOW])

    # TODO fix this... make it a function that is easier and neater and less prone to mistakes.
    m = int(pin.pin[PIN_MONTHSTOPROJECT])
    hg = float(pin.pin[PIN_HASHGROW] / 100)
    #hg2 = float(pin.pin[PIN_HASHGROW2] / 100)
    hg2=0
    pricegrow = float(pin.pin[PIN_PRICEGROW] / 100)
    pricegrow2 = float(pin.pin[PIN_PRICEGROW2] / 100)
    pl = int(pin.pin[PIN_LAG])




    #TODO SANITIZE INPUT - do a better job
    #TODO SANITIZE INPUT - do a better job
    if pin.pin['wattage'] == None or pin.pin['wattage'] <= 0:
        output.toast("invalid wattage - no miners added")
        return
    if pin.pin['hashrate'] == None or pin.pin['hashrate'] <= 0:
        output.toast("invalid hashrate - no miners added")
        return
    if pin.pin[PIN_COST] == None or pin.pin[PIN_COST] <= 0:
        output.toast("invalid cost - no miners added")
        return
    if None in [m, pricegrow, hg]:
        output.toast("missing projection parameters...")
        output.toast("can't leave input field blank", color='error')
        return


    # # we convert the dollar cost to satoshis using the provided bitcoin price at time of equipment purchase
    # pin.pin[PIN_CAPEX] = btc( result['cost'], price=result['btcprice'])


    # # NOW WE HAVE TO CHANGE THE PIN INPUTS PIN_CAPEX AND PIN_EFF
    # # oh... and ALSO the sliders right below them
    # pin.pin[PIN_CAPEX] = pin.pin['play_with_capex'] = round(result['cost'] / result['hashrate'], 2) #TODO warning... I'm rounding numbers
    # pin.pin[PIN_EFF] = pin.pin['play_with_eff'] = round(result['wattage'] / result['hashrate'], 2)

    # # TODO - this will cause a bug... don't set to DEFAULT_P below... have another way!  Unless we make sure this function is only called once... and the value isn't reset???  Hmmm...
    # capexsatsperthpermonth = us.total_capex() / pin.pin[PIN_MONTHSTOPROJECT] / us.total_terahash()
    # capex /= m



    # PRINT EVERYTHING TO THE SCREEN...
    with output.use_scope('projection', clear=True):
        output.put_markdown( "# PROJECTION SUMMARY:" )

    ## ACTUALLY DO THE CALCULATIONS
    res = calculate_projection(
        months=m,
        height=height,
        hashrate=hashrate,
        wattage=wattage,
        price=price,
        networh_hashrate=nh,
        avgfee=avgfee,
        poolfee=poolfee,
        hashgrow=hg,
        hashgrow2=hg2,
        pricegrow=pricegrow,
        pricegrow2=pricegrow2,
        pricelag=pl,
        cost_kWh=rate,
        opex=opex,
        capex=capex,
        resale_percent=0.60
    )

    show_graph(res)
    show_table(res)

    #output.scroll_to('projection', position=output.Position.TOP)


def cost_waschanged(cost: float):
    # if pin.pin[PIN_WATTAGE] == None or pin.pin[PIN_WATTAGE] < 1:
    #     return
    # if hashrate == None or hashrate < 1:
    #     pin.pin[PIN_EFF] = pin.pin["play_with_eff"] = 0
    #     return

    # pin.pin[PIN_EFF] = pin.pin["play_with_eff"] = round(pin.pin[PIN_WATTAGE] / hashrate, 2)

    if cost == None or cost < 1:
        pin.pin[PIN_SAT_PER_TH] = ''
        pin.pin[PIN_COST_SLIDER] = ''
        pin.pin_update(name=PIN_COST, help_text='')
        pin.pin_update(PIN_UPPER_READONLY, value='')
        pin.pin_update(PIN_LOWER_READONLY, value='')
        return
    try:
        pin.pin[PIN_COST_SLIDER] = cost
        hr = float(pin.pin[PIN_HASHRATE])
        dollarsperth = cost / hr
        pin.pin_update(name=PIN_SAT_PER_TH, help_text=f"${dollarsperth:.1f} / TH")

        # again... I'm not a fan of this.. nothing is sanitized
        upperresale_waschanged( int(pin.pin[PIN_RESELL_UPPER]) )
        lowerresale_waschanged( int(pin.pin[PIN_RESELL_UPPER]) )

        btcuponpurchase = float(pin.pin[PIN_BOUGHTATPRICE])
    except Exception as e:
        print(e)
        return
    
    pin.pin_update(name=PIN_COST, help_text=f"{ONE_HUNDRED_MILLION * (cost/btcuponpurchase):,.1f} sats")
    pin.pin[PIN_SAT_PER_TH] = f"{round(btc(cost, price=btcuponpurchase) / hr, 1):,.2f}"

def neversell_waschanged( o ):
    if OPTION_NEVERSELL in o:
        # NEVER SELL
        pin.pin_update(name=PIN_RESELL_UPPER, readonly=True)
        pin.pin_update(name=PIN_RESELL_LOWER, readonly=True)
        pin.pin_update(name=PIN_MONTHSTOPROJECT, label="Expected machine life span")
    else:
        # WILL SELL
        pin.pin_update(name=PIN_RESELL_UPPER, readonly=False)
        pin.pin_update(name=PIN_RESELL_LOWER, readonly=False)
        pin.pin_update(name=PIN_MONTHSTOPROJECT, label="Months until you re-sell this miner")

def upperresale_waschanged(v: int):
    try:
        v = pin.pin[PIN_COST] * (pin.pin[PIN_RESELL_UPPER] / 100)
        pin.pin_update(PIN_UPPER_READONLY, value=v)
    except:
        return

def lowerresale_waschanged(v: int):
    try:
        v = pin.pin[PIN_COST] * (pin.pin[PIN_RESELL_LOWER] / 100)
        pin.pin_update(PIN_LOWER_READONLY, value=v)
    except:
        return
    pass

def hashgrow_waschanged( newval: float ):
    if newval == None:
        return
    
    # THIS DOES NOT WORK-Y WORK... :) SAD EMOJI GOES HERE
    #pin.pin_update(PIN_HASHGROW_SLIDER, max_value=int(newval*2))

    pin.pin_update(PIN_HASHGROW_SLIDER, value=newval)
    pin.pin[PIN_HASHGROW_SLIDER] = newval



#######################
def show_settings():
    with output.use_scope("settings", clear=True):

        output.put_markdown('## Mining equipment purchase consideration')

        output.put_table([[
                pin.put_input(name=PIN_WATTAGE, type='float', label="Wattage"),
                pin.put_input(name=PIN_HASHRATE, type='float', label='Hashrate (in terahash)'),
                pin.put_input(name=PIN_EFF, type='float', label="Efficiency (W/TH)", readonly=True),
                pin.put_slider(name=PIN_EFF_SLIDER, value=0,min_value=1, max_value=170, label="efficiency slider")
            ],[
                pin.put_input(name=PIN_BOUGHTATPRICE, type='float', label='bitcoin price at time of purchase', value=pin.pin[PIN_BTC_PRICE_NOW]),
                pin.put_input(name=PIN_COST, type='float', label='Dollar cost of machine'),
                pin.put_input(name=PIN_SAT_PER_TH, type='float', label="Sats per TH", readonly=True),
                pin.put_slider(name=PIN_COST_SLIDER, value=0,min_value=1, max_value=20_000, step=5, label="purchase amount slider")
            ]])
        pin.pin_on_change(name=PIN_BOUGHTATPRICE, onchange=boughtatprice_waschanged)
        pin.pin_on_change(name=PIN_COST, onchange=cost_waschanged)
        pin.pin_on_change(name=PIN_HASHRATE, onchange=hashrate_waschanged)
        pin.pin_on_change(name=PIN_WATTAGE, onchange=wattage_waschanged)
        pin.pin_on_change(name=PIN_COST_SLIDER, onchange=cost_slider)
        pin.pin_on_change(name=PIN_EFF_SLIDER, onchange=eff_slider)

        #output.put_button("Analyze Miner", onclick=updateminerdata, color='success')

        output.put_markdown("## Equipment resale / Depreciation Recapture")
        output.put_table([[
                pin.put_input(name=PIN_MONTHSTOPROJECT, type='number', value=DEFAULT_MONTHSTOPROJECT, label='Months until you re-sell this miner', help_text="Months to run projection"),
                pin.put_checkbox(name=PIN_NEVERSELL, options=[OPTION_NEVERSELL], value=False)
            ],[
                pin.put_input(name=PIN_RESELL_UPPER, type='number', value=75, label="Resale % UPPER limit", help_text="% percent of purchase price"),
                pin.put_input(name=PIN_UPPER_READONLY, type='number', label="Resale value UPPER LIMIT", readonly=True, help_text="($) resale amount")
            ],[
                pin.put_input(name=PIN_RESELL_LOWER, type='number', value=50, label="Resale % LOWER limit", help_text="% percent of purchase price"),
                pin.put_input(PIN_LOWER_READONLY, type='number', label="Resale value LOWER LIMIT", readonly=True, help_text="($) resale amount")
        ]])
        pin.pin_on_change(name=PIN_NEVERSELL, onchange=neversell_waschanged)
        pin.pin_on_change(PIN_RESELL_UPPER, onchange=upperresale_waschanged)
        pin.pin_on_change(PIN_RESELL_LOWER, onchange=lowerresale_waschanged)

        output.put_markdown("---")
        output.put_markdown("## Bitcoin network state")

        output.put_table([[
            pin.put_input(name=PIN_BTC_PRICE_NOW, type='float', value=pin.pin[PIN_BTC_PRICE_NOW], label="Bitcoin price $"),
            pin.put_input(name=PIN_HEIGHT, type='float', value=pin.pin[PIN_HEIGHT], label="blockchain height"),
            pin.put_input(name=PIN_NETWORKHASHRATE, type='float', value=pin.pin[PIN_NETWORKHASHRATE], label="network hashrate"),
            ],[
            pin.put_input(name=PIN_AVERAGEFEE, type='float', value=pin.pin[PIN_AVERAGEFEE], label="average transaction fees per block", help_text="in satoshi"),
            output.put_button("block fee analysis", onclick=feeanalysis)
            ]
        ])

        output.put_markdown("---")
        output.put_markdown("## Cost-of-production variables")
        output.put_table([[
            pin.put_input(PIN_KWH_RATE, type='float', value= DEFAUL_KPKWH, label='your cost per kilowatt-hour: $'),
            pin.put_input(PIN_POOLFEE, type='float', value= DEFAULT_POOL_FEE, label='mining pool fee: %'),
            pin.put_input(PIN_OPEX, type='float', value= DEFAULT_OPEX, label='monthly operational cost: $'),
        ]])

        output.put_markdown("---")
        output.put_markdown("## Projection Parameters")

        output.put_table([[
            pin.put_input(name=PIN_PRICEGROW, type='float', value=DEFAULT_PRICEGROW, label='Monthly price growth: %', help_text='how fast do you predict the bitcoin price will grow month-to-month?'),
            pin.put_slider(PIN_PRICEGROW_SLIDER, label='Price growth slider', value=DEFAULT_PRICEGROW,min_value=-10.0, max_value=20.0, step=0.1),
            output.put_button("price history analysis", onclick=pricehistory)
            ],[
            pin.put_input(name=PIN_PRICEGROW2, type='float', value=DEFAULT_PRICEGROW2, label='Post-halvening price growth: %', help_text="How fast do you think the price will grow monthly post-halvening (and post 'lag')"),
            pin.put_slider(name="post_halvening_slider", label='Price growth slider', value=DEFAULT_PRICEGROW2,min_value=-10.0, max_value=20.0, step=0.1),
            pin.put_input(name=PIN_LAG, type='float', value=DEFAULT_LAG, label='Halvening price lag (months)', help_text="The price growth post-halvening sometimes lags a few months...")
            ],[
            pin.put_input(name=PIN_HASHGROW, type='float', value=DEFAULT_HASHGROW, label='Monthly hashrate growth: %'),
            pin.put_slider(PIN_HASHGROW_SLIDER, value=DEFAULT_HASHGROW,min_value=-2.0, max_value=10.0, step=0.1),
            output.put_button("hashrate history analysis", onclick=hashratehistory)
            ]
        ])
        pin.pin_on_change(PIN_PRICEGROW_SLIDER, onchange=pricegrow_slider)
        pin.pin_on_change(name=PIN_PRICEGROW2_SLIDER, onchange=pricegrow2_slider)
        pin.pin_on_change(PIN_HASHGROW_SLIDER, onchange=hashgrow_slider)
        pin.pin_on_change(name=PIN_HASHGROW, onchange=hashgrow_waschanged)

        #pin.put_checkbox('verbose', options=['VERBOSE MODE - (put every variable on the spreadsheet)'], inline=True)

        output.put_button( 'RUN PROJECTION', onclick=show_projection, color='warning' )



def init():
    """
        This tries to get the latest bitcoin network data + price
    """
    # make init a popup??? but you can't have a popup call a popup..... maybe the popup will appear when data is being downloaded!!!
    with output.use_scope('init', clear=True):

        path = useful_node()

        if path != None:
            output.put_text("Getting data from node...", scope='init')

            h = node_blockheight(path)
            f = node_avgblockfee(path, nBlocks=2)
            nh = node_networkhashps(path)
            
            output.put_text("Getting price of bitcoin...", scope='init')
            p = query_bitcoinprice()

            if p == -1:
                output.toast("Unable to download current bitcoin price from <some website>")
                p = popup_get_price_from_user()

            pin.pin[PIN_BTC_PRICE_NOW] = p
            pin.pin[PIN_BOUGHTATPRICE] = p
            pin.pin[PIN_HEIGHT] = h
            pin.pin[PIN_AVERAGEFEE] = f
            pin.pin[PIN_NETWORKHASHRATE] = nh

        else:
            if not get_stats_from_internet():

                # run an endless loop until user provides valid network data
                r = popup_get_stats_from_user()
                while r == False:
                    r = popup_get_stats_from_user()

        output.clear(scope='init')

###############################
def main():
#if __name__ == '__main__':
    session.set_env(title="bitcoin mining profit calculator")
    print( CLI_HELPTEXT )

    # https://pywebio.readthedocs.io/en/latest/platform.html
    # https://pywebio.readthedocs.io/en/v1.2.2/guide.html#server-mode-and-script-mode
    # https://github.com/pywebio/PyWebIO/blob/dev/demos/bokeh_app.py
    # I can't believe this fucking works!!!!  Will it ever cause problems? #shrug
    t = threading.Thread(target=session.hold)
    session.register_thread( t )
    t.start()

    with output.use_scope('main', clear=True):
        output.put_markdown( MAIN_TEXT )
        output.put_button("USD - BTC converter", onclick=currencyconverter, color='info')

    show_settings()
    init()

#############################
if __name__ == '__main__':
    # I do it this way because if you're running it on your node over SSH the webpage won't automatically open, you have to click the link
    pywebio.start_server(main, port=8080, debug=True)
    #main()
